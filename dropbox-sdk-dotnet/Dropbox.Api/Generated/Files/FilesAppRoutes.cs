// <auto-generated>
// Auto-generated by StoneAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Files.Routes
{
    using sys = System;
    using io = System.IO;
    using col = System.Collections.Generic;
    using t = System.Threading.Tasks;
    using enc = Dropbox.Api.Stone;

    /// <summary>
    /// <para>The routes for the <see cref="N:Dropbox.Api.Files"/> namespace</para>
    /// </summary>
    public class FilesAppRoutes
    {
        /// <summary>
        /// <para>Initializes a new instance of the <see cref="FilesAppRoutes" /> class.</para>
        /// </summary>
        /// <param name="transport">The transport to use</param>
        internal FilesAppRoutes(enc.ITransport transport)
        {
            this.Transport = transport;
        }

        /// <summary>
        /// <para>Gets the transport used for these routes</para>
        /// </summary>
        internal enc.ITransport Transport { get; private set; }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in
        /// size won't be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="thumbnailV2Arg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailV2Error"/>.</exception>
        public t.Task<enc.IDownloadResponse<PreviewResult>> GetThumbnailV2Async(ThumbnailV2Arg thumbnailV2Arg)
        {
            return this.Transport.SendDownloadRequestAsync<ThumbnailV2Arg, PreviewResult, ThumbnailV2Error>(thumbnailV2Arg, "content", "/files/get_thumbnail_v2", "app", global::Dropbox.Api.Files.ThumbnailV2Arg.Encoder, global::Dropbox.Api.Files.PreviewResult.Decoder, global::Dropbox.Api.Files.ThumbnailV2Error.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="thumbnailV2Arg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnailV2(ThumbnailV2Arg thumbnailV2Arg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetThumbnailV2Async(thumbnailV2Arg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in
        /// size won't be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="resource">Information specifying which file to preview. This could be
        /// a path to a file, a shared link pointing to a file, or a shared link pointing to a
        /// folder, with a relative path.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <param name="mode">How to resize and crop the image to achieve the desired
        /// size.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailV2Error"/>.</exception>
        public t.Task<enc.IDownloadResponse<PreviewResult>> GetThumbnailV2Async(PathOrLink resource,
                                                                                ThumbnailFormat format = null,
                                                                                ThumbnailSize size = null,
                                                                                ThumbnailMode mode = null)
        {
            var thumbnailV2Arg = new ThumbnailV2Arg(resource,
                                                    format,
                                                    size,
                                                    mode);

            return this.GetThumbnailV2Async(thumbnailV2Arg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="resource">Information specifying which file to preview. This could be
        /// a path to a file, a shared link pointing to a file, or a shared link pointing to a
        /// folder, with a relative path.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <param name="mode">How to resize and crop the image to achieve the desired
        /// size.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnailV2(PathOrLink resource,
                                                    ThumbnailFormat format = null,
                                                    ThumbnailSize size = null,
                                                    ThumbnailMode mode = null,
                                                    sys.AsyncCallback callback = null,
                                                    object callbackState = null)
        {
            var thumbnailV2Arg = new ThumbnailV2Arg(resource,
                                                    format,
                                                    size,
                                                    mode);

            return this.BeginGetThumbnailV2(thumbnailV2Arg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get thumbnail route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailV2Error"/>.</exception>
        public enc.IDownloadResponse<PreviewResult> EndGetThumbnailV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<PreviewResult>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Starts returning the contents of a folder. If the result's <see
        /// cref="Dropbox.Api.Files.ListFolderResult.HasMore" /> field is <c>true</c>, call
        /// <see cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> with the
        /// returned <see cref="Dropbox.Api.Files.ListFolderResult.Cursor" /> to retrieve more
        /// entries.</para>
        /// <para>If you're using <see cref="Dropbox.Api.Files.ListFolderArg.Recursive" /> set
        /// to <c>true</c> to keep a local cache of the contents of a Dropbox account, iterate
        /// through each entry in order and process them as follows to keep your local state in
        /// sync:</para>
        /// <para>For each <see cref="FileMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it and remove all its
        /// children.</para>
        /// <para>For each <see cref="FolderMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it but leave the
        /// children as they are. Check the new entry's <see
        /// cref="Dropbox.Api.Files.FolderSharingInfo.ReadOnly" /> and set all its children's
        /// read-only statuses to match.</para>
        /// <para>For each <see cref="DeletedMetadata" />, if your local state has something at
        /// the given path, remove it and all its children. If there's nothing at the given
        /// path, ignore this entry.</para>
        /// <para>Note: <see cref="Auth.RateLimitError" /> may be returned if multiple <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> calls
        /// with same parameters are made simultaneously by same API app for same user. If your
        /// app implements retry logic, please hold off the retry until the previous request
        /// finishes.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderResult, ListFolderError>(listFolderArg, "api", "/files/list_folder", "app", global::Dropbox.Api.Files.ListFolderArg.Encoder, global::Dropbox.Api.Files.ListFolderResult.Decoder, global::Dropbox.Api.Files.ListFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Starts returning the contents of a folder. If the result's <see
        /// cref="Dropbox.Api.Files.ListFolderResult.HasMore" /> field is <c>true</c>, call
        /// <see cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> with the
        /// returned <see cref="Dropbox.Api.Files.ListFolderResult.Cursor" /> to retrieve more
        /// entries.</para>
        /// <para>If you're using <see cref="Dropbox.Api.Files.ListFolderArg.Recursive" /> set
        /// to <c>true</c> to keep a local cache of the contents of a Dropbox account, iterate
        /// through each entry in order and process them as follows to keep your local state in
        /// sync:</para>
        /// <para>For each <see cref="FileMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it and remove all its
        /// children.</para>
        /// <para>For each <see cref="FolderMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it but leave the
        /// children as they are. Check the new entry's <see
        /// cref="Dropbox.Api.Files.FolderSharingInfo.ReadOnly" /> and set all its children's
        /// read-only statuses to match.</para>
        /// <para>For each <see cref="DeletedMetadata" />, if your local state has something at
        /// the given path, remove it and all its children. If there's nothing at the given
        /// path, ignore this entry.</para>
        /// <para>Note: <see cref="Auth.RateLimitError" /> may be returned if multiple <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> calls
        /// with same parameters are made simultaneously by same API app for same user. If your
        /// app implements retry logic, please hold off the retry until the previous request
        /// finishes.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and video. This
        /// parameter will no longer have an effect starting December 2, 2019.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="includeNonDownloadableFiles">If true, include files that are not
        /// downloadable, i.e. Google Docs.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(string path,
                                                        bool recursive = false,
                                                        bool includeMediaInfo = false,
                                                        bool includeDeleted = false,
                                                        bool includeHasExplicitSharedMembers = false,
                                                        bool includeMountedFolders = true,
                                                        uint? limit = null,
                                                        SharedLink sharedLink = null,
                                                        global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                        bool includeNonDownloadableFiles = true)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups,
                                                  includeNonDownloadableFiles);

            return this.ListFolderAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and video. This
        /// parameter will no longer have an effect starting December 2, 2019.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="includeNonDownloadableFiles">If true, include files that are not
        /// downloadable, i.e. Google Docs.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(string path,
                                                bool recursive = false,
                                                bool includeMediaInfo = false,
                                                bool includeDeleted = false,
                                                bool includeHasExplicitSharedMembers = false,
                                                bool includeMountedFolders = true,
                                                uint? limit = null,
                                                SharedLink sharedLink = null,
                                                global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                bool includeNonDownloadableFiles = true,
                                                sys.AsyncCallback callback = null,
                                                object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups,
                                                  includeNonDownloadableFiles);

            return this.BeginListFolder(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderResult EndListFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder, following the same
        /// rules as documented for <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(ListFolderContinueArg listFolderContinueArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderContinueArg, ListFolderResult, ListFolderContinueError>(listFolderContinueArg, "api", "/files/list_folder/continue", "app", global::Dropbox.Api.Files.ListFolderContinueArg.Encoder, global::Dropbox.Api.Files.ListFolderResult.Decoder, global::Dropbox.Api.Files.ListFolderContinueError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(ListFolderContinueArg listFolderContinueArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderContinueAsync(listFolderContinueArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder, following the same
        /// rules as documented for <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(string cursor)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.ListFolderContinueAsync(listFolderContinueArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesAppRoutes.ListFolderContinueAsync" /> <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(string cursor,
                                                        sys.AsyncCallback callback,
                                                        object callbackState = null)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.BeginListFolderContinue(listFolderContinueArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder continue route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public ListFolderResult EndListFolderContinue(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }
    }
}
