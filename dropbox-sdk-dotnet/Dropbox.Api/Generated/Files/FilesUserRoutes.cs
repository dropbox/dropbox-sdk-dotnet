// <auto-generated>
// Auto-generated by StoneAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Files.Routes
{
    using sys = System;
    using io = System.IO;
    using col = System.Collections.Generic;
    using t = System.Threading.Tasks;
    using enc = Dropbox.Api.Stone;

    /// <summary>
    /// <para>The routes for the <see cref="N:Dropbox.Api.Files"/> namespace</para>
    /// </summary>
    public class FilesUserRoutes
    {
        /// <summary>
        /// <para>Initializes a new instance of the <see cref="FilesUserRoutes" />
        /// class.</para>
        /// </summary>
        /// <param name="transport">The transport to use</param>
        internal FilesUserRoutes(enc.ITransport transport)
        {
            this.Transport = transport;
        }

        /// <summary>
        /// <para>Gets the transport used for these routes</para>
        /// </summary>
        internal enc.ITransport Transport { get; private set; }

        /// <summary>
        /// <para>Returns the metadata for a file or folder. This is an alpha endpoint
        /// compatible with the properties API.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="alphaGetMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use GetMetadataAsync instead.")]
        public t.Task<Metadata> AlphaGetMetadataAsync(AlphaGetMetadataArg alphaGetMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<AlphaGetMetadataArg, Metadata, AlphaGetMetadataError>(alphaGetMetadataArg, "api", "/files/alpha/get_metadata", "user", global::Dropbox.Api.Files.AlphaGetMetadataArg.Encoder, global::Dropbox.Api.Files.Metadata.Decoder, global::Dropbox.Api.Files.AlphaGetMetadataError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha get metadata route.</para>
        /// </summary>
        /// <param name="alphaGetMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginGetMetadata instead.")]
        public sys.IAsyncResult BeginAlphaGetMetadata(AlphaGetMetadataArg alphaGetMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.AlphaGetMetadataAsync(alphaGetMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder. This is an alpha endpoint
        /// compatible with the properties API.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="includePropertyTemplates">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set for files with
        /// custom properties.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use GetMetadataAsync instead.")]
        public t.Task<Metadata> AlphaGetMetadataAsync(string path,
                                                      bool includeMediaInfo = false,
                                                      bool includeDeleted = false,
                                                      bool includeHasExplicitSharedMembers = false,
                                                      global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                      col.IEnumerable<string> includePropertyTemplates = null)
        {
            var alphaGetMetadataArg = new AlphaGetMetadataArg(path,
                                                              includeMediaInfo,
                                                              includeDeleted,
                                                              includeHasExplicitSharedMembers,
                                                              includePropertyGroups,
                                                              includePropertyTemplates);

            return this.AlphaGetMetadataAsync(alphaGetMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha get metadata route.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="includePropertyTemplates">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set for files with
        /// custom properties.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginGetMetadata instead.")]
        public sys.IAsyncResult BeginAlphaGetMetadata(string path,
                                                      bool includeMediaInfo = false,
                                                      bool includeDeleted = false,
                                                      bool includeHasExplicitSharedMembers = false,
                                                      global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                      col.IEnumerable<string> includePropertyTemplates = null,
                                                      sys.AsyncCallback callback = null,
                                                      object callbackState = null)
        {
            var alphaGetMetadataArg = new AlphaGetMetadataArg(path,
                                                              includeMediaInfo,
                                                              includeDeleted,
                                                              includeHasExplicitSharedMembers,
                                                              includePropertyGroups,
                                                              includePropertyTemplates);

            return this.BeginAlphaGetMetadata(alphaGetMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the alpha get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndGetMetadata instead.")]
        public Metadata EndAlphaGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request. Note that this
        /// endpoint is part of the properties API alpha and is slightly different from <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="commitInfoWithProperties">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use AlphaUploadAsync instead.")]
        public t.Task<FileMetadata> AlphaUploadAsync(CommitInfoWithProperties commitInfoWithProperties, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfoWithProperties, FileMetadata, UploadErrorWithProperties>(commitInfoWithProperties, body, "content", "/files/alpha/upload", "user", global::Dropbox.Api.Files.CommitInfoWithProperties.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.UploadErrorWithProperties.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha upload route.</para>
        /// </summary>
        /// <param name="commitInfoWithProperties">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginAlphaUpload instead.")]
        public sys.IAsyncResult BeginAlphaUpload(CommitInfoWithProperties commitInfoWithProperties, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.AlphaUploadAsync(commitInfoWithProperties, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request. Note that this
        /// endpoint is part of the properties API alpha and is slightly different from <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="strictConflict">Be more strict about how each <see cref="WriteMode" />
        /// detects conflict. For example, always return a conflict error when <paramref
        /// name="mode" /> = <see cref="Dropbox.Api.Files.WriteMode.Update" /> and the given
        /// "rev" doesn't match the existing file's "rev", even if the existing file has been
        /// deleted.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use AlphaUploadAsync instead.")]
        public t.Task<FileMetadata> AlphaUploadAsync(string path,
                                                     WriteMode mode = null,
                                                     bool autorename = false,
                                                     sys.DateTime? clientModified = null,
                                                     bool mute = false,
                                                     col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups = null,
                                                     bool strictConflict = false,
                                                     io.Stream body = null)
        {
            var commitInfoWithProperties = new CommitInfoWithProperties(path,
                                                                        mode,
                                                                        autorename,
                                                                        clientModified,
                                                                        mute,
                                                                        propertyGroups,
                                                                        strictConflict);

            return this.AlphaUploadAsync(commitInfoWithProperties, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="strictConflict">Be more strict about how each <see cref="WriteMode" />
        /// detects conflict. For example, always return a conflict error when <paramref
        /// name="mode" /> = <see cref="Dropbox.Api.Files.WriteMode.Update" /> and the given
        /// "rev" doesn't match the existing file's "rev", even if the existing file has been
        /// deleted.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginAlphaUpload instead.")]
        public sys.IAsyncResult BeginAlphaUpload(string path,
                                                 WriteMode mode = null,
                                                 bool autorename = false,
                                                 sys.DateTime? clientModified = null,
                                                 bool mute = false,
                                                 col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups = null,
                                                 bool strictConflict = false,
                                                 io.Stream body = null,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var commitInfoWithProperties = new CommitInfoWithProperties(path,
                                                                        mode,
                                                                        autorename,
                                                                        clientModified,
                                                                        mute,
                                                                        propertyGroups,
                                                                        strictConflict);

            return this.BeginAlphaUpload(commitInfoWithProperties, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the alpha upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndAlphaUpload instead.")]
        public FileMetadata EndAlphaUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<RelocationResult> CopyV2Async(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, RelocationResult, RelocationError>(relocationArg, "api", "/files/copy_v2", "user", global::Dropbox.Api.Files.RelocationArg.Encoder, global::Dropbox.Api.Files.RelocationResult.Decoder, global::Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyV2(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyV2Async(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<RelocationResult> CopyV2Async(string fromPath,
                                                    string toPath,
                                                    bool allowSharedFolder = false,
                                                    bool autorename = false,
                                                    bool allowOwnershipTransfer = false)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.CopyV2Async(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyV2(string fromPath,
                                            string toPath,
                                            bool allowSharedFolder = false,
                                            bool autorename = false,
                                            bool allowOwnershipTransfer = false,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.BeginCopyV2(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public RelocationResult EndCopyV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CopyAsync instead.")]
        public t.Task<Metadata> CopyAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/copy", "user", global::Dropbox.Api.Files.RelocationArg.Encoder, global::Dropbox.Api.Files.Metadata.Decoder, global::Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopy instead.")]
        public sys.IAsyncResult BeginCopy(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CopyAsync instead.")]
        public t.Task<Metadata> CopyAsync(string fromPath,
                                          string toPath,
                                          bool allowSharedFolder = false,
                                          bool autorename = false,
                                          bool allowOwnershipTransfer = false)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.CopyAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopy instead.")]
        public sys.IAsyncResult BeginCopy(string fromPath,
                                          string toPath,
                                          bool allowSharedFolder = false,
                                          bool autorename = false,
                                          bool allowOwnershipTransfer = false,
                                          sys.AsyncCallback callback = null,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.BeginCopy(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndCopy instead.")]
        public Metadata EndCopy(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route will replace <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" />. The main
        /// difference is this route will return stutus for each entry, while <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> raises failure if
        /// any entry fails.</para>
        /// <para>This route will either finish synchronously, or return a job ID and do the
        /// async copy job in background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchCheckV2Async" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="relocationBatchArgBase">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchV2Launch> CopyBatchV2Async(RelocationBatchArgBase relocationBatchArgBase)
        {
            return this.Transport.SendRpcRequestAsync<RelocationBatchArgBase, RelocationBatchV2Launch, enc.Empty>(relocationBatchArgBase, "api", "/files/copy_batch_v2", "user", global::Dropbox.Api.Files.RelocationBatchArgBase.Encoder, global::Dropbox.Api.Files.RelocationBatchV2Launch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch route.</para>
        /// </summary>
        /// <param name="relocationBatchArgBase">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyBatchV2(RelocationBatchArgBase relocationBatchArgBase, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyBatchV2Async(relocationBatchArgBase);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route will replace <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" />. The main
        /// difference is this route will return stutus for each entry, while <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> raises failure if
        /// any entry fails.</para>
        /// <para>This route will either finish synchronously, or return a job ID and do the
        /// async copy job in background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchCheckV2Async" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchV2Launch> CopyBatchV2Async(col.IEnumerable<RelocationPath> entries,
                                                                bool autorename = false)
        {
            var relocationBatchArgBase = new RelocationBatchArgBase(entries,
                                                                    autorename);

            return this.CopyBatchV2Async(relocationBatchArgBase);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch route.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyBatchV2(col.IEnumerable<RelocationPath> entries,
                                                 bool autorename = false,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var relocationBatchArgBase = new RelocationBatchArgBase(entries,
                                                                    autorename);

            return this.BeginCopyBatchV2(relocationBatchArgBase, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public RelocationBatchV2Launch EndCopyBatchV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchV2Launch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>If <see cref="Dropbox.Api.Files.RelocationBatchArg.AllowSharedFolder" /> is
        /// false, this route is atomic. If one entry fails, the whole transaction will abort.
        /// If <see cref="Dropbox.Api.Files.RelocationBatchArg.AllowSharedFolder" /> is true,
        /// atomicity is not guaranteed, but it allows you to copy the contents of shared
        /// folders to new locations.</para>
        /// <para>This route will return job ID immediately and do the async copy job in
        /// background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchCheckAsync" /> to check the
        /// job status.</para>
        /// </summary>
        /// <param name="relocationBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        [sys.Obsolete("This function is deprecated, please use CopyBatchAsync instead.")]
        public t.Task<RelocationBatchLaunch> CopyBatchAsync(RelocationBatchArg relocationBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationBatchArg, RelocationBatchLaunch, enc.Empty>(relocationBatchArg, "api", "/files/copy_batch", "user", global::Dropbox.Api.Files.RelocationBatchArg.Encoder, global::Dropbox.Api.Files.RelocationBatchLaunch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch route.</para>
        /// </summary>
        /// <param name="relocationBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopyBatch instead.")]
        public sys.IAsyncResult BeginCopyBatch(RelocationBatchArg relocationBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyBatchAsync(relocationBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>If <see cref="Dropbox.Api.Files.RelocationBatchArg.AllowSharedFolder" /> is
        /// false, this route is atomic. If one entry fails, the whole transaction will abort.
        /// If <see cref="Dropbox.Api.Files.RelocationBatchArg.AllowSharedFolder" /> is true,
        /// atomicity is not guaranteed, but it allows you to copy the contents of shared
        /// folders to new locations.</para>
        /// <para>This route will return job ID immediately and do the async copy job in
        /// background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchCheckAsync" /> to check the
        /// job status.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> will copy
        /// contents in shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <see cref="Dropbox.Api.Files.RelocationPath.FromPath" /> contains shared folder.
        /// This field is always true for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        [sys.Obsolete("This function is deprecated, please use CopyBatchAsync instead.")]
        public t.Task<RelocationBatchLaunch> CopyBatchAsync(col.IEnumerable<RelocationPath> entries,
                                                            bool autorename = false,
                                                            bool allowSharedFolder = false,
                                                            bool allowOwnershipTransfer = false)
        {
            var relocationBatchArg = new RelocationBatchArg(entries,
                                                            autorename,
                                                            allowSharedFolder,
                                                            allowOwnershipTransfer);

            return this.CopyBatchAsync(relocationBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch route.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> will copy
        /// contents in shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <see cref="Dropbox.Api.Files.RelocationPath.FromPath" /> contains shared folder.
        /// This field is always true for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopyBatch instead.")]
        public sys.IAsyncResult BeginCopyBatch(col.IEnumerable<RelocationPath> entries,
                                               bool autorename = false,
                                               bool allowSharedFolder = false,
                                               bool allowOwnershipTransfer = false,
                                               sys.AsyncCallback callback = null,
                                               object callbackState = null)
        {
            var relocationBatchArg = new RelocationBatchArg(entries,
                                                            autorename,
                                                            allowSharedFolder,
                                                            allowOwnershipTransfer);

            return this.BeginCopyBatch(relocationBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        [sys.Obsolete("This function is deprecated, please use EndCopyBatch instead.")]
        public RelocationBatchLaunch EndCopyBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchLaunch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchV2Async" />. It returns
        /// list of results for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchV2JobStatus> CopyBatchCheckV2Async(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, RelocationBatchV2JobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/copy_batch/check_v2", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.RelocationBatchV2JobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyBatchCheckV2(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyBatchCheckV2Async(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchV2Async" />. It returns
        /// list of results for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchV2JobStatus> CopyBatchCheckV2Async(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.CopyBatchCheckV2Async(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyBatchCheckV2(string asyncJobId,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginCopyBatchCheckV2(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy batch check route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public RelocationBatchV2JobStatus EndCopyBatchCheckV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchV2JobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" />. If success, it
        /// returns list of results for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CopyBatchCheckAsync instead.")]
        public t.Task<RelocationBatchJobStatus> CopyBatchCheckAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, RelocationBatchJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/copy_batch/check", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.RelocationBatchJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopyBatchCheck instead.")]
        public sys.IAsyncResult BeginCopyBatchCheck(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" />. If success, it
        /// returns list of results for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CopyBatchCheckAsync instead.")]
        public t.Task<RelocationBatchJobStatus> CopyBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.CopyBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCopyBatchCheck instead.")]
        public sys.IAsyncResult BeginCopyBatchCheck(string asyncJobId,
                                                    sys.AsyncCallback callback,
                                                    object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginCopyBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy batch check route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndCopyBatchCheck instead.")]
        public RelocationBatchJobStatus EndCopyBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a copy reference to a file or folder. This reference string can be used
        /// to save that file or folder to another user's Dropbox by passing it to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceSaveAsync" />.</para>
        /// </summary>
        /// <param name="getCopyReferenceArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public t.Task<GetCopyReferenceResult> CopyReferenceGetAsync(GetCopyReferenceArg getCopyReferenceArg)
        {
            return this.Transport.SendRpcRequestAsync<GetCopyReferenceArg, GetCopyReferenceResult, GetCopyReferenceError>(getCopyReferenceArg, "api", "/files/copy_reference/get", "user", global::Dropbox.Api.Files.GetCopyReferenceArg.Encoder, global::Dropbox.Api.Files.GetCopyReferenceResult.Decoder, global::Dropbox.Api.Files.GetCopyReferenceError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference get route.</para>
        /// </summary>
        /// <param name="getCopyReferenceArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceGet(GetCopyReferenceArg getCopyReferenceArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyReferenceGetAsync(getCopyReferenceArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a copy reference to a file or folder. This reference string can be used
        /// to save that file or folder to another user's Dropbox by passing it to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceSaveAsync" />.</para>
        /// </summary>
        /// <param name="path">The path to the file or folder you want to get a copy reference
        /// to.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public t.Task<GetCopyReferenceResult> CopyReferenceGetAsync(string path)
        {
            var getCopyReferenceArg = new GetCopyReferenceArg(path);

            return this.CopyReferenceGetAsync(getCopyReferenceArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference get route.</para>
        /// </summary>
        /// <param name="path">The path to the file or folder you want to get a copy reference
        /// to.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceGet(string path,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var getCopyReferenceArg = new GetCopyReferenceArg(path);

            return this.BeginCopyReferenceGet(getCopyReferenceArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy reference get route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public GetCopyReferenceResult EndCopyReferenceGet(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetCopyReferenceResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Save a copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceGetAsync" /> to the
        /// user's Dropbox.</para>
        /// </summary>
        /// <param name="saveCopyReferenceArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public t.Task<SaveCopyReferenceResult> CopyReferenceSaveAsync(SaveCopyReferenceArg saveCopyReferenceArg)
        {
            return this.Transport.SendRpcRequestAsync<SaveCopyReferenceArg, SaveCopyReferenceResult, SaveCopyReferenceError>(saveCopyReferenceArg, "api", "/files/copy_reference/save", "user", global::Dropbox.Api.Files.SaveCopyReferenceArg.Encoder, global::Dropbox.Api.Files.SaveCopyReferenceResult.Decoder, global::Dropbox.Api.Files.SaveCopyReferenceError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference save route.</para>
        /// </summary>
        /// <param name="saveCopyReferenceArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceSave(SaveCopyReferenceArg saveCopyReferenceArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyReferenceSaveAsync(saveCopyReferenceArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Save a copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceGetAsync" /> to the
        /// user's Dropbox.</para>
        /// </summary>
        /// <param name="copyReference">A copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceGetAsync" />.</param>
        /// <param name="path">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public t.Task<SaveCopyReferenceResult> CopyReferenceSaveAsync(string copyReference,
                                                                      string path)
        {
            var saveCopyReferenceArg = new SaveCopyReferenceArg(copyReference,
                                                                path);

            return this.CopyReferenceSaveAsync(saveCopyReferenceArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference save route.</para>
        /// </summary>
        /// <param name="copyReference">A copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyReferenceGetAsync" />.</param>
        /// <param name="path">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceSave(string copyReference,
                                                       string path,
                                                       sys.AsyncCallback callback,
                                                       object callbackState = null)
        {
            var saveCopyReferenceArg = new SaveCopyReferenceArg(copyReference,
                                                                path);

            return this.BeginCopyReferenceSave(saveCopyReferenceArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy reference save route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public SaveCopyReferenceResult EndCopyReferenceSave(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveCopyReferenceResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public t.Task<CreateFolderResult> CreateFolderV2Async(CreateFolderArg createFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<CreateFolderArg, CreateFolderResult, CreateFolderError>(createFolderArg, "api", "/files/create_folder_v2", "user", global::Dropbox.Api.Files.CreateFolderArg.Encoder, global::Dropbox.Api.Files.CreateFolderResult.Decoder, global::Dropbox.Api.Files.CreateFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderV2(CreateFolderArg createFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderV2Async(createFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public t.Task<CreateFolderResult> CreateFolderV2Async(string path,
                                                              bool autorename = false)
        {
            var createFolderArg = new CreateFolderArg(path,
                                                      autorename);

            return this.CreateFolderV2Async(createFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderV2(string path,
                                                    bool autorename = false,
                                                    sys.AsyncCallback callback = null,
                                                    object callbackState = null)
        {
            var createFolderArg = new CreateFolderArg(path,
                                                      autorename);

            return this.BeginCreateFolderV2(createFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public CreateFolderResult EndCreateFolderV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<CreateFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CreateFolderAsync instead.")]
        public t.Task<FolderMetadata> CreateFolderAsync(CreateFolderArg createFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<CreateFolderArg, FolderMetadata, CreateFolderError>(createFolderArg, "api", "/files/create_folder", "user", global::Dropbox.Api.Files.CreateFolderArg.Encoder, global::Dropbox.Api.Files.FolderMetadata.Decoder, global::Dropbox.Api.Files.CreateFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCreateFolder instead.")]
        public sys.IAsyncResult BeginCreateFolder(CreateFolderArg createFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderAsync(createFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use CreateFolderAsync instead.")]
        public t.Task<FolderMetadata> CreateFolderAsync(string path,
                                                        bool autorename = false)
        {
            var createFolderArg = new CreateFolderArg(path,
                                                      autorename);

            return this.CreateFolderAsync(createFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginCreateFolder instead.")]
        public sys.IAsyncResult BeginCreateFolder(string path,
                                                  bool autorename = false,
                                                  sys.AsyncCallback callback = null,
                                                  object callbackState = null)
        {
            var createFolderArg = new CreateFolderArg(path,
                                                      autorename);

            return this.BeginCreateFolder(createFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndCreateFolder instead.")]
        public FolderMetadata EndCreateFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FolderMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create multiple folders at once.</para>
        /// <para>This route is asynchronous for large batches, which returns a job ID
        /// immediately and runs the create folder batch asynchronously. Otherwise, creates the
        /// folders and returns the result synchronously for smaller inputs. You can force
        /// asynchronous behaviour by using the <see
        /// cref="Dropbox.Api.Files.CreateFolderBatchArg.ForceAsync" /> flag.  Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CreateFolderBatchCheckAsync" /> to
        /// check the job status.</para>
        /// </summary>
        /// <param name="createFolderBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<CreateFolderBatchLaunch> CreateFolderBatchAsync(CreateFolderBatchArg createFolderBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<CreateFolderBatchArg, CreateFolderBatchLaunch, enc.Empty>(createFolderBatchArg, "api", "/files/create_folder_batch", "user", global::Dropbox.Api.Files.CreateFolderBatchArg.Encoder, global::Dropbox.Api.Files.CreateFolderBatchLaunch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder batch route.</para>
        /// </summary>
        /// <param name="createFolderBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderBatch(CreateFolderBatchArg createFolderBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderBatchAsync(createFolderBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create multiple folders at once.</para>
        /// <para>This route is asynchronous for large batches, which returns a job ID
        /// immediately and runs the create folder batch asynchronously. Otherwise, creates the
        /// folders and returns the result synchronously for smaller inputs. You can force
        /// asynchronous behaviour by using the <see
        /// cref="Dropbox.Api.Files.CreateFolderBatchArg.ForceAsync" /> flag.  Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CreateFolderBatchCheckAsync" /> to
        /// check the job status.</para>
        /// </summary>
        /// <param name="paths">List of paths to be created in the user's Dropbox. Duplicate
        /// path arguments in the batch are considered only once.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <param name="forceAsync">Whether to force the create to happen
        /// asynchronously.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<CreateFolderBatchLaunch> CreateFolderBatchAsync(col.IEnumerable<string> paths,
                                                                      bool autorename = false,
                                                                      bool forceAsync = false)
        {
            var createFolderBatchArg = new CreateFolderBatchArg(paths,
                                                                autorename,
                                                                forceAsync);

            return this.CreateFolderBatchAsync(createFolderBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder batch route.</para>
        /// </summary>
        /// <param name="paths">List of paths to be created in the user's Dropbox. Duplicate
        /// path arguments in the batch are considered only once.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the folder to avoid the conflict.</param>
        /// <param name="forceAsync">Whether to force the create to happen
        /// asynchronously.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderBatch(col.IEnumerable<string> paths,
                                                       bool autorename = false,
                                                       bool forceAsync = false,
                                                       sys.AsyncCallback callback = null,
                                                       object callbackState = null)
        {
            var createFolderBatchArg = new CreateFolderBatchArg(paths,
                                                                autorename,
                                                                forceAsync);

            return this.BeginCreateFolderBatch(createFolderBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public CreateFolderBatchLaunch EndCreateFolderBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<CreateFolderBatchLaunch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CreateFolderBatchAsync" />. If
        /// success, it returns list of result for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<CreateFolderBatchJobStatus> CreateFolderBatchCheckAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, CreateFolderBatchJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/create_folder_batch/check", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.CreateFolderBatchJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderBatchCheck(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CreateFolderBatchAsync" />. If
        /// success, it returns list of result for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<CreateFolderBatchJobStatus> CreateFolderBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.CreateFolderBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolderBatchCheck(string asyncJobId,
                                                            sys.AsyncCallback callback,
                                                            object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginCreateFolderBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder batch check
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public CreateFolderBatchJobStatus EndCreateFolderBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<CreateFolderBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task<DeleteResult> DeleteV2Async(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, DeleteResult, DeleteError>(deleteArg, "api", "/files/delete_v2", "user", global::Dropbox.Api.Files.DeleteArg.Encoder, global::Dropbox.Api.Files.DeleteResult.Decoder, global::Dropbox.Api.Files.DeleteError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteV2(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteV2Async(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task<DeleteResult> DeleteV2Async(string path,
                                                  string parentRev = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.DeleteV2Async(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteV2(string path,
                                              string parentRev = null,
                                              sys.AsyncCallback callback = null,
                                              object callbackState = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.BeginDeleteV2(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public DeleteResult EndDeleteV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<DeleteResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use DeleteAsync instead.")]
        public t.Task<Metadata> DeleteAsync(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, Metadata, DeleteError>(deleteArg, "api", "/files/delete", "user", global::Dropbox.Api.Files.DeleteArg.Encoder, global::Dropbox.Api.Files.Metadata.Decoder, global::Dropbox.Api.Files.DeleteError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginDelete instead.")]
        public sys.IAsyncResult BeginDelete(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteAsync(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use DeleteAsync instead.")]
        public t.Task<Metadata> DeleteAsync(string path,
                                            string parentRev = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.DeleteAsync(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginDelete instead.")]
        public sys.IAsyncResult BeginDelete(string path,
                                            string parentRev = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.BeginDelete(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndDelete instead.")]
        public Metadata EndDelete(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Delete multiple files/folders at once.</para>
        /// <para>This route is asynchronous, which returns a job ID immediately and runs the
        /// delete batch asynchronously. Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.DeleteBatchCheckAsync" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="deleteBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<DeleteBatchLaunch> DeleteBatchAsync(DeleteBatchArg deleteBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteBatchArg, DeleteBatchLaunch, enc.Empty>(deleteBatchArg, "api", "/files/delete_batch", "user", global::Dropbox.Api.Files.DeleteBatchArg.Encoder, global::Dropbox.Api.Files.DeleteBatchLaunch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete batch route.</para>
        /// </summary>
        /// <param name="deleteBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteBatch(DeleteBatchArg deleteBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteBatchAsync(deleteBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Delete multiple files/folders at once.</para>
        /// <para>This route is asynchronous, which returns a job ID immediately and runs the
        /// delete batch asynchronously. Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.DeleteBatchCheckAsync" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="entries">The entries</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<DeleteBatchLaunch> DeleteBatchAsync(col.IEnumerable<DeleteArg> entries)
        {
            var deleteBatchArg = new DeleteBatchArg(entries);

            return this.DeleteBatchAsync(deleteBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete batch route.</para>
        /// </summary>
        /// <param name="entries">The entries</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteBatch(col.IEnumerable<DeleteArg> entries,
                                                 sys.AsyncCallback callback,
                                                 object callbackState = null)
        {
            var deleteBatchArg = new DeleteBatchArg(entries);

            return this.BeginDeleteBatch(deleteBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public DeleteBatchLaunch EndDeleteBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<DeleteBatchLaunch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.DeleteBatchAsync" />. If success, it
        /// returns list of result for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<DeleteBatchJobStatus> DeleteBatchCheckAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, DeleteBatchJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/delete_batch/check", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.DeleteBatchJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteBatchCheck(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.DeleteBatchAsync" />. If success, it
        /// returns list of result for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<DeleteBatchJobStatus> DeleteBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.DeleteBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDeleteBatchCheck(string asyncJobId,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginDeleteBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete batch check route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public DeleteBatchJobStatus EndDeleteBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<DeleteBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(DownloadArg downloadArg)
        {
            return this.Transport.SendDownloadRequestAsync<DownloadArg, FileMetadata, DownloadError>(downloadArg, "content", "/files/download", "user", global::Dropbox.Api.Files.DownloadArg.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.DownloadError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(DownloadArg downloadArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DownloadAsync(downloadArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Please specify revision in <paramref name="path" />
        /// instead.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(string path,
                                                                         string rev = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.DownloadAsync(downloadArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Please specify revision in <paramref name="path" />
        /// instead.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(string path,
                                              string rev = null,
                                              sys.AsyncCallback callback = null,
                                              object callbackState = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.BeginDownload(downloadArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the download route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndDownload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Download a folder from the user's Dropbox, as a zip file. The folder must be
        /// less than 20 GB in size and have fewer than 10,000 total files. The input cannot be
        /// a single file. Any single file must be less than 4GB in size.</para>
        /// </summary>
        /// <param name="downloadZipArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadZipError"/>.</exception>
        public t.Task<enc.IDownloadResponse<DownloadZipResult>> DownloadZipAsync(DownloadZipArg downloadZipArg)
        {
            return this.Transport.SendDownloadRequestAsync<DownloadZipArg, DownloadZipResult, DownloadZipError>(downloadZipArg, "content", "/files/download_zip", "user", global::Dropbox.Api.Files.DownloadZipArg.Encoder, global::Dropbox.Api.Files.DownloadZipResult.Decoder, global::Dropbox.Api.Files.DownloadZipError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download zip route.</para>
        /// </summary>
        /// <param name="downloadZipArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownloadZip(DownloadZipArg downloadZipArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DownloadZipAsync(downloadZipArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Download a folder from the user's Dropbox, as a zip file. The folder must be
        /// less than 20 GB in size and have fewer than 10,000 total files. The input cannot be
        /// a single file. Any single file must be less than 4GB in size.</para>
        /// </summary>
        /// <param name="path">The path of the folder to download.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadZipError"/>.</exception>
        public t.Task<enc.IDownloadResponse<DownloadZipResult>> DownloadZipAsync(string path)
        {
            var downloadZipArg = new DownloadZipArg(path);

            return this.DownloadZipAsync(downloadZipArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download zip route.</para>
        /// </summary>
        /// <param name="path">The path of the folder to download.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownloadZip(string path,
                                                 sys.AsyncCallback callback,
                                                 object callbackState = null)
        {
            var downloadZipArg = new DownloadZipArg(path);

            return this.BeginDownloadZip(downloadZipArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the download zip route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadZipError"/>.</exception>
        public enc.IDownloadResponse<DownloadZipResult> EndDownloadZip(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<DownloadZipResult>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(GetMetadataArg getMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<GetMetadataArg, Metadata, GetMetadataError>(getMetadataArg, "api", "/files/get_metadata", "user", global::Dropbox.Api.Files.GetMetadataArg.Encoder, global::Dropbox.Api.Files.Metadata.Decoder, global::Dropbox.Api.Files.GetMetadataError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(GetMetadataArg getMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetMetadataAsync(getMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(string path,
                                                 bool includeMediaInfo = false,
                                                 bool includeDeleted = false,
                                                 bool includeHasExplicitSharedMembers = false,
                                                 global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null)
        {
            var getMetadataArg = new GetMetadataArg(path,
                                                    includeMediaInfo,
                                                    includeDeleted,
                                                    includeHasExplicitSharedMembers,
                                                    includePropertyGroups);

            return this.GetMetadataAsync(getMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(string path,
                                                 bool includeMediaInfo = false,
                                                 bool includeDeleted = false,
                                                 bool includeHasExplicitSharedMembers = false,
                                                 global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var getMetadataArg = new GetMetadataArg(path,
                                                    includeMediaInfo,
                                                    includeDeleted,
                                                    includeHasExplicitSharedMembers,
                                                    includePropertyGroups);

            return this.BeginGetMetadata(getMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public Metadata EndGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a preview for a file.</para>
        /// <para>Currently, PDF previews are generated for files with the following
        /// extensions: .ai, .doc, .docm, .docx, .eps, .odp, .odt, .pps, .ppsm, .ppsx, .ppt,
        /// .pptm, .pptx, .rtf.</para>
        /// <para>HTML previews are generated for files with the following extensions: .csv,
        /// .ods, .xls, .xlsm, .xlsx.</para>
        /// <para>Other formats will return an unsupported extension error.</para>
        /// </summary>
        /// <param name="previewArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetPreviewAsync(PreviewArg previewArg)
        {
            return this.Transport.SendDownloadRequestAsync<PreviewArg, FileMetadata, PreviewError>(previewArg, "content", "/files/get_preview", "user", global::Dropbox.Api.Files.PreviewArg.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.PreviewError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get preview route.</para>
        /// </summary>
        /// <param name="previewArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetPreview(PreviewArg previewArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetPreviewAsync(previewArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a preview for a file.</para>
        /// <para>Currently, PDF previews are generated for files with the following
        /// extensions: .ai, .doc, .docm, .docx, .eps, .odp, .odt, .pps, .ppsm, .ppsx, .ppt,
        /// .pptm, .pptx, .rtf.</para>
        /// <para>HTML previews are generated for files with the following extensions: .csv,
        /// .ods, .xls, .xlsm, .xlsx.</para>
        /// <para>Other formats will return an unsupported extension error.</para>
        /// </summary>
        /// <param name="path">The path of the file to preview.</param>
        /// <param name="rev">Please specify revision in <paramref name="path" />
        /// instead.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetPreviewAsync(string path,
                                                                           string rev = null)
        {
            var previewArg = new PreviewArg(path,
                                            rev);

            return this.GetPreviewAsync(previewArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get preview route.</para>
        /// </summary>
        /// <param name="path">The path of the file to preview.</param>
        /// <param name="rev">Please specify revision in <paramref name="path" />
        /// instead.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetPreview(string path,
                                                string rev = null,
                                                sys.AsyncCallback callback = null,
                                                object callbackState = null)
        {
            var previewArg = new PreviewArg(path,
                                            rev);

            return this.BeginGetPreview(previewArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get preview route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndGetPreview(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a temporary link to stream content of a file. This link will expire in
        /// four hours and afterwards you will get 410 Gone. So this URL should not be used to
        /// display content directly in the browser.  Content-Type of the link is determined
        /// automatically by the file's mime type.</para>
        /// </summary>
        /// <param name="getTemporaryLinkArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public t.Task<GetTemporaryLinkResult> GetTemporaryLinkAsync(GetTemporaryLinkArg getTemporaryLinkArg)
        {
            return this.Transport.SendRpcRequestAsync<GetTemporaryLinkArg, GetTemporaryLinkResult, GetTemporaryLinkError>(getTemporaryLinkArg, "api", "/files/get_temporary_link", "user", global::Dropbox.Api.Files.GetTemporaryLinkArg.Encoder, global::Dropbox.Api.Files.GetTemporaryLinkResult.Decoder, global::Dropbox.Api.Files.GetTemporaryLinkError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary link route.</para>
        /// </summary>
        /// <param name="getTemporaryLinkArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryLink(GetTemporaryLinkArg getTemporaryLinkArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetTemporaryLinkAsync(getTemporaryLinkArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a temporary link to stream content of a file. This link will expire in
        /// four hours and afterwards you will get 410 Gone. So this URL should not be used to
        /// display content directly in the browser.  Content-Type of the link is determined
        /// automatically by the file's mime type.</para>
        /// </summary>
        /// <param name="path">The path to the file you want a temporary link to.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public t.Task<GetTemporaryLinkResult> GetTemporaryLinkAsync(string path)
        {
            var getTemporaryLinkArg = new GetTemporaryLinkArg(path);

            return this.GetTemporaryLinkAsync(getTemporaryLinkArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary link route.</para>
        /// </summary>
        /// <param name="path">The path to the file you want a temporary link to.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryLink(string path,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var getTemporaryLinkArg = new GetTemporaryLinkArg(path);

            return this.BeginGetTemporaryLink(getTemporaryLinkArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get temporary link route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public GetTemporaryLinkResult EndGetTemporaryLink(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetTemporaryLinkResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a one-time use temporary upload link to upload a file to a Dropbox
        /// location.</para>
        /// <para></para>
        /// <para>This endpoint acts as a delayed <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />. The returned
        /// temporary upload link may be used to make a POST request with the data to be
        /// uploaded. The upload will then be perfomed with the <see cref="CommitInfo" />
        /// previously provided to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.GetTemporaryUploadLinkAsync" /> but
        /// evaluated only upon consumption. Hence, errors stemming from invalid <see
        /// cref="CommitInfo" /> with respect to the state of the user's Dropbox will only be
        /// communicated at consumption time. Additionally, these errors are surfaced as
        /// generic HTTP 409 Conflict responses, potentially hiding issue details. The maximum
        /// temporary upload link duration is 4 hours. Upon consumption or expiration, a new
        /// link will have to be generated. Multiple links may exist for a specific upload path
        /// at any given time.</para>
        /// <para></para>
        /// <para>The POST request on the temporary upload link must have its Content-Type set
        /// to "application/octet-stream".</para>
        /// <para></para>
        /// <para>Example temporary upload link consumption request:</para>
        /// <para></para>
        /// <para>curl -X POST
        /// https://dl.dropboxusercontent.com/apitul/1/bNi2uIYF51cVBND</para>
        /// <para>--header "Content-Type: application/octet-stream"</para>
        /// <para>--data-binary @local_file.txt</para>
        /// <para></para>
        /// <para>A successful temporary upload link consumption request returns the content
        /// hash of the uploaded data in JSON format.</para>
        /// <para></para>
        /// <para>Example succesful temporary upload link consumption response:</para>
        /// <para>{"content-hash": "599d71033d700ac892a0e48fa61b125d2f5994"}</para>
        /// <para></para>
        /// <para>An unsuccessful temporary upload link consumption request returns any of the
        /// following status codes:</para>
        /// <para></para>
        /// <para>HTTP 400 Bad Request: Content-Type is not one of application/octet-stream and
        /// text/plain or request is invalid.</para>
        /// <para>HTTP 409 Conflict: The temporary upload link does not exist or is currently
        /// unavailable, the upload failed, or another error happened.</para>
        /// <para>HTTP 410 Gone: The temporary upload link is expired or consumed.</para>
        /// <para></para>
        /// <para>Example unsuccessful temporary upload link consumption response:</para>
        /// <para>Temporary upload link has been recently consumed.</para>
        /// </summary>
        /// <param name="getTemporaryUploadLinkArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<GetTemporaryUploadLinkResult> GetTemporaryUploadLinkAsync(GetTemporaryUploadLinkArg getTemporaryUploadLinkArg)
        {
            return this.Transport.SendRpcRequestAsync<GetTemporaryUploadLinkArg, GetTemporaryUploadLinkResult, enc.Empty>(getTemporaryUploadLinkArg, "api", "/files/get_temporary_upload_link", "user", global::Dropbox.Api.Files.GetTemporaryUploadLinkArg.Encoder, global::Dropbox.Api.Files.GetTemporaryUploadLinkResult.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary upload link route.</para>
        /// </summary>
        /// <param name="getTemporaryUploadLinkArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryUploadLink(GetTemporaryUploadLinkArg getTemporaryUploadLinkArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetTemporaryUploadLinkAsync(getTemporaryUploadLinkArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a one-time use temporary upload link to upload a file to a Dropbox
        /// location.</para>
        /// <para></para>
        /// <para>This endpoint acts as a delayed <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />. The returned
        /// temporary upload link may be used to make a POST request with the data to be
        /// uploaded. The upload will then be perfomed with the <see cref="CommitInfo" />
        /// previously provided to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.GetTemporaryUploadLinkAsync" /> but
        /// evaluated only upon consumption. Hence, errors stemming from invalid <see
        /// cref="CommitInfo" /> with respect to the state of the user's Dropbox will only be
        /// communicated at consumption time. Additionally, these errors are surfaced as
        /// generic HTTP 409 Conflict responses, potentially hiding issue details. The maximum
        /// temporary upload link duration is 4 hours. Upon consumption or expiration, a new
        /// link will have to be generated. Multiple links may exist for a specific upload path
        /// at any given time.</para>
        /// <para></para>
        /// <para>The POST request on the temporary upload link must have its Content-Type set
        /// to "application/octet-stream".</para>
        /// <para></para>
        /// <para>Example temporary upload link consumption request:</para>
        /// <para></para>
        /// <para>curl -X POST
        /// https://dl.dropboxusercontent.com/apitul/1/bNi2uIYF51cVBND</para>
        /// <para>--header "Content-Type: application/octet-stream"</para>
        /// <para>--data-binary @local_file.txt</para>
        /// <para></para>
        /// <para>A successful temporary upload link consumption request returns the content
        /// hash of the uploaded data in JSON format.</para>
        /// <para></para>
        /// <para>Example succesful temporary upload link consumption response:</para>
        /// <para>{"content-hash": "599d71033d700ac892a0e48fa61b125d2f5994"}</para>
        /// <para></para>
        /// <para>An unsuccessful temporary upload link consumption request returns any of the
        /// following status codes:</para>
        /// <para></para>
        /// <para>HTTP 400 Bad Request: Content-Type is not one of application/octet-stream and
        /// text/plain or request is invalid.</para>
        /// <para>HTTP 409 Conflict: The temporary upload link does not exist or is currently
        /// unavailable, the upload failed, or another error happened.</para>
        /// <para>HTTP 410 Gone: The temporary upload link is expired or consumed.</para>
        /// <para></para>
        /// <para>Example unsuccessful temporary upload link consumption response:</para>
        /// <para>Temporary upload link has been recently consumed.</para>
        /// </summary>
        /// <param name="commitInfo">Contains the path and other optional modifiers for the
        /// future upload commit. Equivalent to the parameters provided to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />.</param>
        /// <param name="duration">How long before this link expires, in seconds.  Attempting
        /// to start an upload with this link longer than this period  of time after link
        /// creation will result in an error.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<GetTemporaryUploadLinkResult> GetTemporaryUploadLinkAsync(CommitInfo commitInfo,
                                                                                double duration = 14400.0)
        {
            var getTemporaryUploadLinkArg = new GetTemporaryUploadLinkArg(commitInfo,
                                                                          duration);

            return this.GetTemporaryUploadLinkAsync(getTemporaryUploadLinkArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary upload link route.</para>
        /// </summary>
        /// <param name="commitInfo">Contains the path and other optional modifiers for the
        /// future upload commit. Equivalent to the parameters provided to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadAsync" />.</param>
        /// <param name="duration">How long before this link expires, in seconds.  Attempting
        /// to start an upload with this link longer than this period  of time after link
        /// creation will result in an error.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryUploadLink(CommitInfo commitInfo,
                                                            double duration = 14400.0,
                                                            sys.AsyncCallback callback = null,
                                                            object callbackState = null)
        {
            var getTemporaryUploadLinkArg = new GetTemporaryUploadLinkArg(commitInfo,
                                                                          duration);

            return this.BeginGetTemporaryUploadLink(getTemporaryUploadLinkArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get temporary upload link
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public GetTemporaryUploadLinkResult EndGetTemporaryUploadLink(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetTemporaryUploadLinkResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(ThumbnailArg thumbnailArg)
        {
            return this.Transport.SendDownloadRequestAsync<ThumbnailArg, FileMetadata, ThumbnailError>(thumbnailArg, "content", "/files/get_thumbnail", "user", global::Dropbox.Api.Files.ThumbnailArg.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.ThumbnailError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(ThumbnailArg thumbnailArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetThumbnailAsync(thumbnailArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <param name="mode">How to resize and crop the image to achieve the desired
        /// size.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(string path,
                                                                             ThumbnailFormat format = null,
                                                                             ThumbnailSize size = null,
                                                                             ThumbnailMode mode = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size,
                                                mode);

            return this.GetThumbnailAsync(thumbnailArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <param name="mode">How to resize and crop the image to achieve the desired
        /// size.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(string path,
                                                  ThumbnailFormat format = null,
                                                  ThumbnailSize size = null,
                                                  ThumbnailMode mode = null,
                                                  sys.AsyncCallback callback = null,
                                                  object callbackState = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size,
                                                mode);

            return this.BeginGetThumbnail(thumbnailArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get thumbnail route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndGetThumbnail(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get thumbnails for a list of images. We allow up to 25 thumbnails in a single
        /// batch.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="getThumbnailBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetThumbnailBatchError"/>.</exception>
        public t.Task<GetThumbnailBatchResult> GetThumbnailBatchAsync(GetThumbnailBatchArg getThumbnailBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<GetThumbnailBatchArg, GetThumbnailBatchResult, GetThumbnailBatchError>(getThumbnailBatchArg, "content", "/files/get_thumbnail_batch", "user", global::Dropbox.Api.Files.GetThumbnailBatchArg.Encoder, global::Dropbox.Api.Files.GetThumbnailBatchResult.Decoder, global::Dropbox.Api.Files.GetThumbnailBatchError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail batch route.</para>
        /// </summary>
        /// <param name="getThumbnailBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnailBatch(GetThumbnailBatchArg getThumbnailBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetThumbnailBatchAsync(getThumbnailBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get thumbnails for a list of images. We allow up to 25 thumbnails in a single
        /// batch.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="entries">List of files to get thumbnails.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetThumbnailBatchError"/>.</exception>
        public t.Task<GetThumbnailBatchResult> GetThumbnailBatchAsync(col.IEnumerable<ThumbnailArg> entries)
        {
            var getThumbnailBatchArg = new GetThumbnailBatchArg(entries);

            return this.GetThumbnailBatchAsync(getThumbnailBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail batch route.</para>
        /// </summary>
        /// <param name="entries">List of files to get thumbnails.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnailBatch(col.IEnumerable<ThumbnailArg> entries,
                                                       sys.AsyncCallback callback,
                                                       object callbackState = null)
        {
            var getThumbnailBatchArg = new GetThumbnailBatchArg(entries);

            return this.BeginGetThumbnailBatch(getThumbnailBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get thumbnail batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetThumbnailBatchError"/>.</exception>
        public GetThumbnailBatchResult EndGetThumbnailBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetThumbnailBatchResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Starts returning the contents of a folder. If the result's <see
        /// cref="Dropbox.Api.Files.ListFolderResult.HasMore" /> field is <c>true</c>, call
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />
        /// with the returned <see cref="Dropbox.Api.Files.ListFolderResult.Cursor" /> to
        /// retrieve more entries.</para>
        /// <para>If you're using <see cref="Dropbox.Api.Files.ListFolderArg.Recursive" /> set
        /// to <c>true</c> to keep a local cache of the contents of a Dropbox account, iterate
        /// through each entry in order and process them as follows to keep your local state in
        /// sync:</para>
        /// <para>For each <see cref="FileMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it and remove all its
        /// children.</para>
        /// <para>For each <see cref="FolderMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it but leave the
        /// children as they are. Check the new entry's <see
        /// cref="Dropbox.Api.Files.FolderSharingInfo.ReadOnly" /> and set all its children's
        /// read-only statuses to match.</para>
        /// <para>For each <see cref="DeletedMetadata" />, if your local state has something at
        /// the given path, remove it and all its children. If there's nothing at the given
        /// path, ignore this entry.</para>
        /// <para>Note: <see cref="Auth.RateLimitError" /> may be returned if multiple <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> calls
        /// with same parameters are made simultaneously by same API app for same user. If your
        /// app implements retry logic, please hold off the retry until the previous request
        /// finishes.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderResult, ListFolderError>(listFolderArg, "api", "/files/list_folder", "user", global::Dropbox.Api.Files.ListFolderArg.Encoder, global::Dropbox.Api.Files.ListFolderResult.Decoder, global::Dropbox.Api.Files.ListFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Starts returning the contents of a folder. If the result's <see
        /// cref="Dropbox.Api.Files.ListFolderResult.HasMore" /> field is <c>true</c>, call
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />
        /// with the returned <see cref="Dropbox.Api.Files.ListFolderResult.Cursor" /> to
        /// retrieve more entries.</para>
        /// <para>If you're using <see cref="Dropbox.Api.Files.ListFolderArg.Recursive" /> set
        /// to <c>true</c> to keep a local cache of the contents of a Dropbox account, iterate
        /// through each entry in order and process them as follows to keep your local state in
        /// sync:</para>
        /// <para>For each <see cref="FileMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it and remove all its
        /// children.</para>
        /// <para>For each <see cref="FolderMetadata" />, store the new entry at the given path
        /// in your local state. If the required parent folders don't exist yet, create them.
        /// If there's already something else at the given path, replace it but leave the
        /// children as they are. Check the new entry's <see
        /// cref="Dropbox.Api.Files.FolderSharingInfo.ReadOnly" /> and set all its children's
        /// read-only statuses to match.</para>
        /// <para>For each <see cref="DeletedMetadata" />, if your local state has something at
        /// the given path, remove it and all its children. If there's nothing at the given
        /// path, ignore this entry.</para>
        /// <para>Note: <see cref="Auth.RateLimitError" /> may be returned if multiple <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" /> calls
        /// with same parameters are made simultaneously by same API app for same user. If your
        /// app implements retry logic, please hold off the retry until the previous request
        /// finishes.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(string path,
                                                        bool recursive = false,
                                                        bool includeMediaInfo = false,
                                                        bool includeDeleted = false,
                                                        bool includeHasExplicitSharedMembers = false,
                                                        bool includeMountedFolders = true,
                                                        uint? limit = null,
                                                        SharedLink sharedLink = null,
                                                        global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups);

            return this.ListFolderAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(string path,
                                                bool recursive = false,
                                                bool includeMediaInfo = false,
                                                bool includeDeleted = false,
                                                bool includeHasExplicitSharedMembers = false,
                                                bool includeMountedFolders = true,
                                                uint? limit = null,
                                                SharedLink sharedLink = null,
                                                global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                sys.AsyncCallback callback = null,
                                                object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups);

            return this.BeginListFolder(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderResult EndListFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder, following the same
        /// rules as documented for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(ListFolderContinueArg listFolderContinueArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderContinueArg, ListFolderResult, ListFolderContinueError>(listFolderContinueArg, "api", "/files/list_folder/continue", "user", global::Dropbox.Api.Files.ListFolderContinueArg.Encoder, global::Dropbox.Api.Files.ListFolderResult.Decoder, global::Dropbox.Api.Files.ListFolderContinueError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(ListFolderContinueArg listFolderContinueArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderContinueAsync(listFolderContinueArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder, following the same
        /// rules as documented for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(string cursor)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.ListFolderContinueAsync(listFolderContinueArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(string cursor,
                                                        sys.AsyncCallback callback,
                                                        object callbackState = null)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.BeginListFolderContinue(listFolderContinueArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder continue route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public ListFolderResult EndListFolderContinue(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>A way to quickly get a cursor for the folder's state. Unlike <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderGetLatestCursorAsync" />
        /// doesn't return any entries. This endpoint is for app which only needs to know about
        /// new files and modifications and doesn't need to know about files that already exist
        /// in Dropbox.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderGetLatestCursorResult> ListFolderGetLatestCursorAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderGetLatestCursorResult, ListFolderError>(listFolderArg, "api", "/files/list_folder/get_latest_cursor", "user", global::Dropbox.Api.Files.ListFolderArg.Encoder, global::Dropbox.Api.Files.ListFolderGetLatestCursorResult.Decoder, global::Dropbox.Api.Files.ListFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder get latest cursor
        /// route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderGetLatestCursor(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderGetLatestCursorAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>A way to quickly get a cursor for the folder's state. Unlike <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" />, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderGetLatestCursorAsync" />
        /// doesn't return any entries. This endpoint is for app which only needs to know about
        /// new files and modifications and doesn't need to know about files that already exist
        /// in Dropbox.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderGetLatestCursorResult> ListFolderGetLatestCursorAsync(string path,
                                                                                      bool recursive = false,
                                                                                      bool includeMediaInfo = false,
                                                                                      bool includeDeleted = false,
                                                                                      bool includeHasExplicitSharedMembers = false,
                                                                                      bool includeMountedFolders = true,
                                                                                      uint? limit = null,
                                                                                      SharedLink sharedLink = null,
                                                                                      global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups);

            return this.ListFolderGetLatestCursorAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder get latest cursor
        /// route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includeMountedFolders">If true, the results will include entries under
        /// mounted folders which includes app folder, shared folder and team folder.</param>
        /// <param name="limit">The maximum number of results to return per request. Note: This
        /// is an approximate number and there can be slightly more entries returned in some
        /// cases.</param>
        /// <param name="sharedLink">A shared link to list the contents of. If the link is
        /// password-protected, the password must be provided. If this field is present, <see
        /// cref="Dropbox.Api.Files.ListFolderArg.Path" /> will be relative to root of the
        /// shared link. Only non-recursive mode is supported for shared link.</param>
        /// <param name="includePropertyGroups">If set to a valid list of template IDs, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set if there exists
        /// property data associated with the file and each of the listed templates.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderGetLatestCursor(string path,
                                                               bool recursive = false,
                                                               bool includeMediaInfo = false,
                                                               bool includeDeleted = false,
                                                               bool includeHasExplicitSharedMembers = false,
                                                               bool includeMountedFolders = true,
                                                               uint? limit = null,
                                                               SharedLink sharedLink = null,
                                                               global::Dropbox.Api.FileProperties.TemplateFilterBase includePropertyGroups = null,
                                                               sys.AsyncCallback callback = null,
                                                               object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers,
                                                  includeMountedFolders,
                                                  limit,
                                                  sharedLink,
                                                  includePropertyGroups);

            return this.BeginListFolderGetLatestCursor(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder get latest cursor
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderGetLatestCursorResult EndListFolderGetLatestCursor(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderGetLatestCursorResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>A longpoll endpoint to wait for changes on an account. In conjunction with
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />,
        /// this call gives you a low-latency way to monitor an account for file changes. The
        /// connection will block until there are changes available or a timeout occurs. This
        /// endpoint is useful mostly for client-side apps. If you're looking for server-side
        /// notifications, check out our <a
        /// href="https://www.dropbox.com/developers/reference/webhooks">webhooks
        /// documentation</a>.</para>
        /// </summary>
        /// <param name="listFolderLongpollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public t.Task<ListFolderLongpollResult> ListFolderLongpollAsync(ListFolderLongpollArg listFolderLongpollArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderLongpollArg, ListFolderLongpollResult, ListFolderLongpollError>(listFolderLongpollArg, "notify", "/files/list_folder/longpoll", "noauth", global::Dropbox.Api.Files.ListFolderLongpollArg.Encoder, global::Dropbox.Api.Files.ListFolderLongpollResult.Decoder, global::Dropbox.Api.Files.ListFolderLongpollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder longpoll route.</para>
        /// </summary>
        /// <param name="listFolderLongpollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderLongpoll(ListFolderLongpollArg listFolderLongpollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderLongpollAsync(listFolderLongpollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>A longpoll endpoint to wait for changes on an account. In conjunction with
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />,
        /// this call gives you a low-latency way to monitor an account for file changes. The
        /// connection will block until there are changes available or a timeout occurs. This
        /// endpoint is useful mostly for client-side apps. If you're looking for server-side
        /// notifications, check out our <a
        /// href="https://www.dropbox.com/developers/reference/webhooks">webhooks
        /// documentation</a>.</para>
        /// </summary>
        /// <param name="cursor">A cursor as returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />. Cursors
        /// retrieved by setting <see cref="Dropbox.Api.Files.ListFolderArg.IncludeMediaInfo"
        /// /> to <c>true</c> are not supported.</param>
        /// <param name="timeout">A timeout in seconds. The request will block for at most this
        /// length of time, plus up to 90 seconds of random jitter added to avoid the
        /// thundering herd problem. Care should be taken when using this parameter, as some
        /// network infrastructure does not support long timeouts.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public t.Task<ListFolderLongpollResult> ListFolderLongpollAsync(string cursor,
                                                                        ulong timeout = 30)
        {
            var listFolderLongpollArg = new ListFolderLongpollArg(cursor,
                                                                  timeout);

            return this.ListFolderLongpollAsync(listFolderLongpollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder longpoll route.</para>
        /// </summary>
        /// <param name="cursor">A cursor as returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.ListFolderContinueAsync" />. Cursors
        /// retrieved by setting <see cref="Dropbox.Api.Files.ListFolderArg.IncludeMediaInfo"
        /// /> to <c>true</c> are not supported.</param>
        /// <param name="timeout">A timeout in seconds. The request will block for at most this
        /// length of time, plus up to 90 seconds of random jitter added to avoid the
        /// thundering herd problem. Care should be taken when using this parameter, as some
        /// network infrastructure does not support long timeouts.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderLongpoll(string cursor,
                                                        ulong timeout = 30,
                                                        sys.AsyncCallback callback = null,
                                                        object callbackState = null)
        {
            var listFolderLongpollArg = new ListFolderLongpollArg(cursor,
                                                                  timeout);

            return this.BeginListFolderLongpoll(listFolderLongpollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder longpoll route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public ListFolderLongpollResult EndListFolderLongpoll(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderLongpollResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns revisions for files based on a file path or a file id. The file path
        /// or file id is identified from the latest file entry at the given file path or id.
        /// This end point allows your app to query either by file path or file id by setting
        /// the mode parameter appropriately.</para>
        /// <para>In the <see cref="Dropbox.Api.Files.ListRevisionsMode.Path" /> (default)
        /// mode, all revisions at the same file path as the latest file entry are returned. If
        /// revisions with the same file id are desired, then mode must be set to <see
        /// cref="Dropbox.Api.Files.ListRevisionsMode.Id" />. The <see
        /// cref="Dropbox.Api.Files.ListRevisionsMode.Id" /> mode is useful to retrieve
        /// revisions for a given file across moves or renames.</para>
        /// </summary>
        /// <param name="listRevisionsArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public t.Task<ListRevisionsResult> ListRevisionsAsync(ListRevisionsArg listRevisionsArg)
        {
            return this.Transport.SendRpcRequestAsync<ListRevisionsArg, ListRevisionsResult, ListRevisionsError>(listRevisionsArg, "api", "/files/list_revisions", "user", global::Dropbox.Api.Files.ListRevisionsArg.Encoder, global::Dropbox.Api.Files.ListRevisionsResult.Decoder, global::Dropbox.Api.Files.ListRevisionsError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list revisions route.</para>
        /// </summary>
        /// <param name="listRevisionsArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListRevisions(ListRevisionsArg listRevisionsArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListRevisionsAsync(listRevisionsArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns revisions for files based on a file path or a file id. The file path
        /// or file id is identified from the latest file entry at the given file path or id.
        /// This end point allows your app to query either by file path or file id by setting
        /// the mode parameter appropriately.</para>
        /// <para>In the <see cref="Dropbox.Api.Files.ListRevisionsMode.Path" /> (default)
        /// mode, all revisions at the same file path as the latest file entry are returned. If
        /// revisions with the same file id are desired, then mode must be set to <see
        /// cref="Dropbox.Api.Files.ListRevisionsMode.Id" />. The <see
        /// cref="Dropbox.Api.Files.ListRevisionsMode.Id" /> mode is useful to retrieve
        /// revisions for a given file across moves or renames.</para>
        /// </summary>
        /// <param name="path">The path to the file you want to see the revisions of.</param>
        /// <param name="mode">Determines the behavior of the API in listing the revisions for
        /// a given file path or id.</param>
        /// <param name="limit">The maximum number of revision entries returned.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public t.Task<ListRevisionsResult> ListRevisionsAsync(string path,
                                                              ListRevisionsMode mode = null,
                                                              ulong limit = 10)
        {
            var listRevisionsArg = new ListRevisionsArg(path,
                                                        mode,
                                                        limit);

            return this.ListRevisionsAsync(listRevisionsArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list revisions route.</para>
        /// </summary>
        /// <param name="path">The path to the file you want to see the revisions of.</param>
        /// <param name="mode">Determines the behavior of the API in listing the revisions for
        /// a given file path or id.</param>
        /// <param name="limit">The maximum number of revision entries returned.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListRevisions(string path,
                                                   ListRevisionsMode mode = null,
                                                   ulong limit = 10,
                                                   sys.AsyncCallback callback = null,
                                                   object callbackState = null)
        {
            var listRevisionsArg = new ListRevisionsArg(path,
                                                        mode,
                                                        limit);

            return this.BeginListRevisions(listRevisionsArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list revisions route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public ListRevisionsResult EndListRevisions(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListRevisionsResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<RelocationResult> MoveV2Async(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, RelocationResult, RelocationError>(relocationArg, "api", "/files/move_v2", "user", global::Dropbox.Api.Files.RelocationArg.Encoder, global::Dropbox.Api.Files.RelocationResult.Decoder, global::Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveV2(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveV2Async(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<RelocationResult> MoveV2Async(string fromPath,
                                                    string toPath,
                                                    bool allowSharedFolder = false,
                                                    bool autorename = false,
                                                    bool allowOwnershipTransfer = false)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.MoveV2Async(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveV2(string fromPath,
                                            string toPath,
                                            bool allowSharedFolder = false,
                                            bool autorename = false,
                                            bool allowOwnershipTransfer = false,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.BeginMoveV2(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public RelocationResult EndMoveV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use MoveAsync instead.")]
        public t.Task<Metadata> MoveAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/move", "user", global::Dropbox.Api.Files.RelocationArg.Encoder, global::Dropbox.Api.Files.Metadata.Decoder, global::Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginMove instead.")]
        public sys.IAsyncResult BeginMove(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use MoveAsync instead.")]
        public t.Task<Metadata> MoveAsync(string fromPath,
                                          string toPath,
                                          bool allowSharedFolder = false,
                                          bool autorename = false,
                                          bool allowOwnershipTransfer = false)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.MoveAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyAsync" /> will copy contents in
        /// shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <paramref name="fromPath" /> contains shared folder. This field is always true
        /// for <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveAsync" />.</param>
        /// <param name="autorename">If there's a conflict, have the Dropbox server try to
        /// autorename the file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginMove instead.")]
        public sys.IAsyncResult BeginMove(string fromPath,
                                          string toPath,
                                          bool allowSharedFolder = false,
                                          bool autorename = false,
                                          bool allowOwnershipTransfer = false,
                                          sys.AsyncCallback callback = null,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath,
                                                  allowSharedFolder,
                                                  autorename,
                                                  allowOwnershipTransfer);

            return this.BeginMove(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndMove instead.")]
        public Metadata EndMove(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route will replace <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchV2Async" />. The main
        /// difference is this route will return stutus for each entry, while <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" /> raises failure if
        /// any entry fails.</para>
        /// <para>This route will either finish synchronously, or return a job ID and do the
        /// async move job in background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchCheckV2Async" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="moveBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchV2Launch> MoveBatchV2Async(MoveBatchArg moveBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<MoveBatchArg, RelocationBatchV2Launch, enc.Empty>(moveBatchArg, "api", "/files/move_batch_v2", "user", global::Dropbox.Api.Files.MoveBatchArg.Encoder, global::Dropbox.Api.Files.RelocationBatchV2Launch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch route.</para>
        /// </summary>
        /// <param name="moveBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchV2(MoveBatchArg moveBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveBatchV2Async(moveBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route will replace <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchV2Async" />. The main
        /// difference is this route will return stutus for each entry, while <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" /> raises failure if
        /// any entry fails.</para>
        /// <para>This route will either finish synchronously, or return a job ID and do the
        /// async move job in background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchCheckV2Async" /> to check
        /// the job status.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchV2Launch> MoveBatchV2Async(col.IEnumerable<RelocationPath> entries,
                                                                bool autorename = false,
                                                                bool allowOwnershipTransfer = false)
        {
            var moveBatchArg = new MoveBatchArg(entries,
                                                autorename,
                                                allowOwnershipTransfer);

            return this.MoveBatchV2Async(moveBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch route.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchV2(col.IEnumerable<RelocationPath> entries,
                                                 bool autorename = false,
                                                 bool allowOwnershipTransfer = false,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var moveBatchArg = new MoveBatchArg(entries,
                                                autorename,
                                                allowOwnershipTransfer);

            return this.BeginMoveBatchV2(moveBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public RelocationBatchV2Launch EndMoveBatchV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchV2Launch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route is 'all or nothing', which means if one entry fails, the whole
        /// transaction will abort.</para>
        /// <para>This route will return job ID immediately and do the async moving job in
        /// background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchCheckAsync" /> to check the
        /// job status.</para>
        /// </summary>
        /// <param name="relocationBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchLaunch> MoveBatchAsync(RelocationBatchArg relocationBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationBatchArg, RelocationBatchLaunch, enc.Empty>(relocationBatchArg, "api", "/files/move_batch", "user", global::Dropbox.Api.Files.RelocationBatchArg.Encoder, global::Dropbox.Api.Files.RelocationBatchLaunch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch route.</para>
        /// </summary>
        /// <param name="relocationBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatch(RelocationBatchArg relocationBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveBatchAsync(relocationBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move multiple files or folders to different locations at once in the user's
        /// Dropbox.</para>
        /// <para>This route is 'all or nothing', which means if one entry fails, the whole
        /// transaction will abort.</para>
        /// <para>This route will return job ID immediately and do the async moving job in
        /// background. Please use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchCheckAsync" /> to check the
        /// job status.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> will copy
        /// contents in shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <see cref="Dropbox.Api.Files.RelocationPath.FromPath" /> contains shared folder.
        /// This field is always true for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<RelocationBatchLaunch> MoveBatchAsync(col.IEnumerable<RelocationPath> entries,
                                                            bool autorename = false,
                                                            bool allowSharedFolder = false,
                                                            bool allowOwnershipTransfer = false)
        {
            var relocationBatchArg = new RelocationBatchArg(entries,
                                                            autorename,
                                                            allowSharedFolder,
                                                            allowOwnershipTransfer);

            return this.MoveBatchAsync(relocationBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch route.</para>
        /// </summary>
        /// <param name="entries">List of entries to be moved or copied. Each entry is <see
        /// cref="RelocationPath" />.</param>
        /// <param name="autorename">If there's a conflict with any file, have the Dropbox
        /// server try to autorename that file to avoid the conflict.</param>
        /// <param name="allowSharedFolder">If true, <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.CopyBatchAsync" /> will copy
        /// contents in shared folder, otherwise <see
        /// cref="Dropbox.Api.Files.RelocationError.CantCopySharedFolder" /> will be returned
        /// if <see cref="Dropbox.Api.Files.RelocationPath.FromPath" /> contains shared folder.
        /// This field is always true for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />.</param>
        /// <param name="allowOwnershipTransfer">Allow moves by owner even if it would result
        /// in an ownership transfer for the content being moved. This does not apply to
        /// copies.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatch(col.IEnumerable<RelocationPath> entries,
                                               bool autorename = false,
                                               bool allowSharedFolder = false,
                                               bool allowOwnershipTransfer = false,
                                               sys.AsyncCallback callback = null,
                                               object callbackState = null)
        {
            var relocationBatchArg = new RelocationBatchArg(entries,
                                                            autorename,
                                                            allowSharedFolder,
                                                            allowOwnershipTransfer);

            return this.BeginMoveBatch(relocationBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move batch route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public RelocationBatchLaunch EndMoveBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchLaunch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchV2Async" />. It returns
        /// list of results for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchV2JobStatus> MoveBatchCheckV2Async(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, RelocationBatchV2JobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/move_batch/check_v2", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.RelocationBatchV2JobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchCheckV2(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveBatchCheckV2Async(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchV2Async" />. It returns
        /// list of results for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchV2JobStatus> MoveBatchCheckV2Async(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.MoveBatchCheckV2Async(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchCheckV2(string asyncJobId,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginMoveBatchCheckV2(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move batch check route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public RelocationBatchV2JobStatus EndMoveBatchCheckV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchV2JobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />. If success, it
        /// returns list of results for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchJobStatus> MoveBatchCheckAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, RelocationBatchJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/move_batch/check", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.RelocationBatchJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch check route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchCheck(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.MoveBatchAsync" />. If success, it
        /// returns list of results for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<RelocationBatchJobStatus> MoveBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.MoveBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move batch check route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMoveBatchCheck(string asyncJobId,
                                                    sys.AsyncCallback callback,
                                                    object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginMoveBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move batch check route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public RelocationBatchJobStatus EndMoveBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<RelocationBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Permanently delete the file or folder at a given path (see
        /// https://www.dropbox.com/en/help/40).</para>
        /// <para>Note: This endpoint is only available for Dropbox Business apps.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task PermanentlyDeleteAsync(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, enc.Empty, DeleteError>(deleteArg, "api", "/files/permanently_delete", "user", global::Dropbox.Api.Files.DeleteArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.Files.DeleteError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the permanently delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPermanentlyDelete(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PermanentlyDeleteAsync(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Permanently delete the file or folder at a given path (see
        /// https://www.dropbox.com/en/help/40).</para>
        /// <para>Note: This endpoint is only available for Dropbox Business apps.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task PermanentlyDeleteAsync(string path,
                                             string parentRev = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.PermanentlyDeleteAsync(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the permanently delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="parentRev">Perform delete if given "rev" matches the existing file's
        /// latest "rev". This field does not support deleting a folder.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPermanentlyDelete(string path,
                                                       string parentRev = null,
                                                       sys.AsyncCallback callback = null,
                                                       object callbackState = null)
        {
            var deleteArg = new DeleteArg(path,
                                          parentRev);

            return this.BeginPermanentlyDelete(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the permanently delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public void EndPermanentlyDelete(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>The properties add route</para>
        /// </summary>
        /// <param name="addPropertiesArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.AddPropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesAddAsync(global::Dropbox.Api.FileProperties.AddPropertiesArg addPropertiesArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.FileProperties.AddPropertiesArg, enc.Empty, global::Dropbox.Api.FileProperties.AddPropertiesError>(addPropertiesArg, "api", "/files/properties/add", "user", global::Dropbox.Api.FileProperties.AddPropertiesArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.FileProperties.AddPropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties add route.</para>
        /// </summary>
        /// <param name="addPropertiesArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesAdd(global::Dropbox.Api.FileProperties.AddPropertiesArg addPropertiesArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesAddAsync(addPropertiesArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>The properties add route</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyGroups">The property groups which are to be added to a Dropbox
        /// file.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.AddPropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesAddAsync(string path,
                                         col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups)
        {
            var addPropertiesArg = new global::Dropbox.Api.FileProperties.AddPropertiesArg(path,
                                                                                           propertyGroups);

            return this.PropertiesAddAsync(addPropertiesArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties add route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyGroups">The property groups which are to be added to a Dropbox
        /// file.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesAdd(string path,
                                                   col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups,
                                                   sys.AsyncCallback callback,
                                                   object callbackState = null)
        {
            var addPropertiesArg = new global::Dropbox.Api.FileProperties.AddPropertiesArg(path,
                                                                                           propertyGroups);

            return this.BeginPropertiesAdd(addPropertiesArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties add route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.AddPropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public void EndPropertiesAdd(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>The properties overwrite route</para>
        /// </summary>
        /// <param name="overwritePropertyGroupArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.InvalidPropertyGroupError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesOverwriteAsync(global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg overwritePropertyGroupArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg, enc.Empty, global::Dropbox.Api.FileProperties.InvalidPropertyGroupError>(overwritePropertyGroupArg, "api", "/files/properties/overwrite", "user", global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.FileProperties.InvalidPropertyGroupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties overwrite route.</para>
        /// </summary>
        /// <param name="overwritePropertyGroupArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesOverwrite(global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg overwritePropertyGroupArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesOverwriteAsync(overwritePropertyGroupArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>The properties overwrite route</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyGroups">The property groups "snapshot" updates to force
        /// apply.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.InvalidPropertyGroupError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesOverwriteAsync(string path,
                                               col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups)
        {
            var overwritePropertyGroupArg = new global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg(path,
                                                                                                             propertyGroups);

            return this.PropertiesOverwriteAsync(overwritePropertyGroupArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties overwrite route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyGroups">The property groups "snapshot" updates to force
        /// apply.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesOverwrite(string path,
                                                         col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var overwritePropertyGroupArg = new global::Dropbox.Api.FileProperties.OverwritePropertyGroupArg(path,
                                                                                                             propertyGroups);

            return this.BeginPropertiesOverwrite(overwritePropertyGroupArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties overwrite route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.InvalidPropertyGroupError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public void EndPropertiesOverwrite(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>The properties remove route</para>
        /// </summary>
        /// <param name="removePropertiesArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.RemovePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesRemoveAsync(global::Dropbox.Api.FileProperties.RemovePropertiesArg removePropertiesArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.FileProperties.RemovePropertiesArg, enc.Empty, global::Dropbox.Api.FileProperties.RemovePropertiesError>(removePropertiesArg, "api", "/files/properties/remove", "user", global::Dropbox.Api.FileProperties.RemovePropertiesArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.FileProperties.RemovePropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties remove route.</para>
        /// </summary>
        /// <param name="removePropertiesArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesRemove(global::Dropbox.Api.FileProperties.RemovePropertiesArg removePropertiesArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesRemoveAsync(removePropertiesArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>The properties remove route</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyTemplateIds">A list of identifiers for a template created by
        /// <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesUserRoutes.TemplatesAddForUserAsync"
        /// /> or <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesTeamRoutes.TemplatesAddForTeamAsync"
        /// />.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.RemovePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesRemoveAsync(string path,
                                            col.IEnumerable<string> propertyTemplateIds)
        {
            var removePropertiesArg = new global::Dropbox.Api.FileProperties.RemovePropertiesArg(path,
                                                                                                 propertyTemplateIds);

            return this.PropertiesRemoveAsync(removePropertiesArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties remove route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="propertyTemplateIds">A list of identifiers for a template created by
        /// <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesUserRoutes.TemplatesAddForUserAsync"
        /// /> or <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesTeamRoutes.TemplatesAddForTeamAsync"
        /// />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesRemove(string path,
                                                      col.IEnumerable<string> propertyTemplateIds,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var removePropertiesArg = new global::Dropbox.Api.FileProperties.RemovePropertiesArg(path,
                                                                                                 propertyTemplateIds);

            return this.BeginPropertiesRemove(removePropertiesArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties remove route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.RemovePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public void EndPropertiesRemove(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>The properties template get route</para>
        /// </summary>
        /// <param name="getTemplateArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.TemplateError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task<global::Dropbox.Api.FileProperties.GetTemplateResult> PropertiesTemplateGetAsync(global::Dropbox.Api.FileProperties.GetTemplateArg getTemplateArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.FileProperties.GetTemplateArg, global::Dropbox.Api.FileProperties.GetTemplateResult, global::Dropbox.Api.FileProperties.TemplateError>(getTemplateArg, "api", "/files/properties/template/get", "user", global::Dropbox.Api.FileProperties.GetTemplateArg.Encoder, global::Dropbox.Api.FileProperties.GetTemplateResult.Decoder, global::Dropbox.Api.FileProperties.TemplateError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template get route.</para>
        /// </summary>
        /// <param name="getTemplateArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesTemplateGet(global::Dropbox.Api.FileProperties.GetTemplateArg getTemplateArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesTemplateGetAsync(getTemplateArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>The properties template get route</para>
        /// </summary>
        /// <param name="templateId">An identifier for template added by route  See <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesUserRoutes.TemplatesAddForUserAsync"
        /// /> or <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesTeamRoutes.TemplatesAddForTeamAsync"
        /// />.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.TemplateError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task<global::Dropbox.Api.FileProperties.GetTemplateResult> PropertiesTemplateGetAsync(string templateId)
        {
            var getTemplateArg = new global::Dropbox.Api.FileProperties.GetTemplateArg(templateId);

            return this.PropertiesTemplateGetAsync(getTemplateArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template get route.</para>
        /// </summary>
        /// <param name="templateId">An identifier for template added by route  See <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesUserRoutes.TemplatesAddForUserAsync"
        /// /> or <see
        /// cref="Dropbox.Api.FileProperties.Routes.FilePropertiesTeamRoutes.TemplatesAddForTeamAsync"
        /// />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesTemplateGet(string templateId,
                                                           sys.AsyncCallback callback,
                                                           object callbackState = null)
        {
            var getTemplateArg = new global::Dropbox.Api.FileProperties.GetTemplateArg(templateId);

            return this.BeginPropertiesTemplateGet(getTemplateArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties template get route
        /// to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.TemplateError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public global::Dropbox.Api.FileProperties.GetTemplateResult EndPropertiesTemplateGet(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<global::Dropbox.Api.FileProperties.GetTemplateResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>The properties template list route</para>
        /// </summary>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.TemplateError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task<global::Dropbox.Api.FileProperties.ListTemplateResult> PropertiesTemplateListAsync()
        {
            return this.Transport.SendRpcRequestAsync<enc.Empty, global::Dropbox.Api.FileProperties.ListTemplateResult, global::Dropbox.Api.FileProperties.TemplateError>(enc.Empty.Instance, "api", "/files/properties/template/list", "user", enc.EmptyEncoder.Instance, global::Dropbox.Api.FileProperties.ListTemplateResult.Decoder, global::Dropbox.Api.FileProperties.TemplateError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template list route.</para>
        /// </summary>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesTemplateList(sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesTemplateListAsync();

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties template list route
        /// to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.TemplateError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public global::Dropbox.Api.FileProperties.ListTemplateResult EndPropertiesTemplateList(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<global::Dropbox.Api.FileProperties.ListTemplateResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>The properties update route</para>
        /// </summary>
        /// <param name="updatePropertiesArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.UpdatePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesUpdateAsync(global::Dropbox.Api.FileProperties.UpdatePropertiesArg updatePropertiesArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.FileProperties.UpdatePropertiesArg, enc.Empty, global::Dropbox.Api.FileProperties.UpdatePropertiesError>(updatePropertiesArg, "api", "/files/properties/update", "user", global::Dropbox.Api.FileProperties.UpdatePropertiesArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.FileProperties.UpdatePropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties update route.</para>
        /// </summary>
        /// <param name="updatePropertiesArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesUpdate(global::Dropbox.Api.FileProperties.UpdatePropertiesArg updatePropertiesArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesUpdateAsync(updatePropertiesArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>The properties update route</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="updatePropertyGroups">The property groups "delta" updates to
        /// apply.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.UpdatePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public t.Task PropertiesUpdateAsync(string path,
                                            col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroupUpdate> updatePropertyGroups)
        {
            var updatePropertiesArg = new global::Dropbox.Api.FileProperties.UpdatePropertiesArg(path,
                                                                                                 updatePropertyGroups);

            return this.PropertiesUpdateAsync(updatePropertiesArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties update route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file or folder.</param>
        /// <param name="updatePropertyGroups">The property groups "delta" updates to
        /// apply.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated")]
        public sys.IAsyncResult BeginPropertiesUpdate(string path,
                                                      col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroupUpdate> updatePropertyGroups,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var updatePropertiesArg = new global::Dropbox.Api.FileProperties.UpdatePropertiesArg(path,
                                                                                                 updatePropertyGroups);

            return this.BeginPropertiesUpdate(updatePropertiesArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties update route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.FileProperties.UpdatePropertiesError"/>.</exception>
        [sys.Obsolete("This function is deprecated")]
        public void EndPropertiesUpdate(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Restore a specific revision of a file to the given path.</para>
        /// </summary>
        /// <param name="restoreArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public t.Task<FileMetadata> RestoreAsync(RestoreArg restoreArg)
        {
            return this.Transport.SendRpcRequestAsync<RestoreArg, FileMetadata, RestoreError>(restoreArg, "api", "/files/restore", "user", global::Dropbox.Api.Files.RestoreArg.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.RestoreError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the restore route.</para>
        /// </summary>
        /// <param name="restoreArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginRestore(RestoreArg restoreArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.RestoreAsync(restoreArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Restore a specific revision of a file to the given path.</para>
        /// </summary>
        /// <param name="path">The path to save the restored file.</param>
        /// <param name="rev">The revision to restore.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public t.Task<FileMetadata> RestoreAsync(string path,
                                                 string rev)
        {
            var restoreArg = new RestoreArg(path,
                                            rev);

            return this.RestoreAsync(restoreArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the restore route.</para>
        /// </summary>
        /// <param name="path">The path to save the restored file.</param>
        /// <param name="rev">The revision to restore.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginRestore(string path,
                                             string rev,
                                             sys.AsyncCallback callback,
                                             object callbackState = null)
        {
            var restoreArg = new RestoreArg(path,
                                            rev);

            return this.BeginRestore(restoreArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the restore route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public FileMetadata EndRestore(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Save the data from a specified URL into a file in user's Dropbox.</para>
        /// <para>Note that the transfer from the URL must complete within 5 minutes, or the
        /// operation will time out and the job will fail.</para>
        /// <para>If the given path already exists, the file will be renamed to avoid the
        /// conflict (e.g. myfile (1).txt).</para>
        /// </summary>
        /// <param name="saveUrlArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public t.Task<SaveUrlResult> SaveUrlAsync(SaveUrlArg saveUrlArg)
        {
            return this.Transport.SendRpcRequestAsync<SaveUrlArg, SaveUrlResult, SaveUrlError>(saveUrlArg, "api", "/files/save_url", "user", global::Dropbox.Api.Files.SaveUrlArg.Encoder, global::Dropbox.Api.Files.SaveUrlResult.Decoder, global::Dropbox.Api.Files.SaveUrlError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url route.</para>
        /// </summary>
        /// <param name="saveUrlArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrl(SaveUrlArg saveUrlArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SaveUrlAsync(saveUrlArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Save the data from a specified URL into a file in user's Dropbox.</para>
        /// <para>Note that the transfer from the URL must complete within 5 minutes, or the
        /// operation will time out and the job will fail.</para>
        /// <para>If the given path already exists, the file will be renamed to avoid the
        /// conflict (e.g. myfile (1).txt).</para>
        /// </summary>
        /// <param name="path">The path in Dropbox where the URL will be saved to.</param>
        /// <param name="url">The URL to be saved.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public t.Task<SaveUrlResult> SaveUrlAsync(string path,
                                                  string url)
        {
            var saveUrlArg = new SaveUrlArg(path,
                                            url);

            return this.SaveUrlAsync(saveUrlArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url route.</para>
        /// </summary>
        /// <param name="path">The path in Dropbox where the URL will be saved to.</param>
        /// <param name="url">The URL to be saved.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrl(string path,
                                             string url,
                                             sys.AsyncCallback callback,
                                             object callbackState = null)
        {
            var saveUrlArg = new SaveUrlArg(path,
                                            url);

            return this.BeginSaveUrl(saveUrlArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the save url route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public SaveUrlResult EndSaveUrl(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveUrlResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Check the status of a <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.SaveUrlAsync" /> job.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<SaveUrlJobStatus> SaveUrlCheckJobStatusAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, SaveUrlJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/save_url/check_job_status", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.SaveUrlJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url check job status route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrlCheckJobStatus(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SaveUrlCheckJobStatusAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Check the status of a <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.SaveUrlAsync" /> job.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<SaveUrlJobStatus> SaveUrlCheckJobStatusAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.SaveUrlCheckJobStatusAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url check job status route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrlCheckJobStatus(string asyncJobId,
                                                           sys.AsyncCallback callback,
                                                           object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginSaveUrlCheckJobStatus(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the save url check job status
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public SaveUrlJobStatus EndSaveUrlCheckJobStatus(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveUrlJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// <para>Note: Recent changes may not immediately be reflected in search results due
        /// to a short delay in indexing.</para>
        /// </summary>
        /// <param name="searchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResult> SearchAsync(SearchArg searchArg)
        {
            return this.Transport.SendRpcRequestAsync<SearchArg, SearchResult, SearchError>(searchArg, "api", "/files/search", "user", global::Dropbox.Api.Files.SearchArg.Encoder, global::Dropbox.Api.Files.SearchResult.Decoder, global::Dropbox.Api.Files.SearchError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="searchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(SearchArg searchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SearchAsync(searchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// <para>Note: Recent changes may not immediately be reflected in search results due
        /// to a short delay in indexing.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename). Note that searching file content is only available for Dropbox
        /// Business accounts.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResult> SearchAsync(string path,
                                                string query,
                                                ulong start = 0,
                                                ulong maxResults = 100,
                                                SearchMode mode = null)
        {
            var searchArg = new SearchArg(path,
                                          query,
                                          start,
                                          maxResults,
                                          mode);

            return this.SearchAsync(searchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename). Note that searching file content is only available for Dropbox
        /// Business accounts.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(string path,
                                            string query,
                                            ulong start = 0,
                                            ulong maxResults = 100,
                                            SearchMode mode = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var searchArg = new SearchArg(path,
                                          query,
                                          start,
                                          maxResults,
                                          mode);

            return this.BeginSearch(searchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the search route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public SearchResult EndSearch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SearchResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" />.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(CommitInfo commitInfo, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfo, FileMetadata, UploadError>(commitInfo, body, "content", "/files/upload", "user", global::Dropbox.Api.Files.CommitInfo.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.UploadError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(CommitInfo commitInfo, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadAsync(commitInfo, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" />.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="strictConflict">Be more strict about how each <see cref="WriteMode" />
        /// detects conflict. For example, always return a conflict error when <paramref
        /// name="mode" /> = <see cref="Dropbox.Api.Files.WriteMode.Update" /> and the given
        /// "rev" doesn't match the existing file's "rev", even if the existing file has been
        /// deleted.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(string path,
                                                WriteMode mode = null,
                                                bool autorename = false,
                                                sys.DateTime? clientModified = null,
                                                bool mute = false,
                                                col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups = null,
                                                bool strictConflict = false,
                                                io.Stream body = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute,
                                            propertyGroups,
                                            strictConflict);

            return this.UploadAsync(commitInfo, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="strictConflict">Be more strict about how each <see cref="WriteMode" />
        /// detects conflict. For example, always return a conflict error when <paramref
        /// name="mode" /> = <see cref="Dropbox.Api.Files.WriteMode.Update" /> and the given
        /// "rev" doesn't match the existing file's "rev", even if the existing file has been
        /// deleted.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(string path,
                                            WriteMode mode = null,
                                            bool autorename = false,
                                            sys.DateTime? clientModified = null,
                                            bool mute = false,
                                            col.IEnumerable<global::Dropbox.Api.FileProperties.PropertyGroup> propertyGroups = null,
                                            bool strictConflict = false,
                                            io.Stream body = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute,
                                            propertyGroups,
                                            strictConflict);

            return this.BeginUpload(commitInfo, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public FileMetadata EndUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>When the parameter close is set, this call will close the session.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="uploadSessionAppendArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendV2Async(UploadSessionAppendArg uploadSessionAppendArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionAppendArg, enc.Empty, UploadSessionLookupError>(uploadSessionAppendArg, body, "content", "/files/upload_session/append_v2", "user", global::Dropbox.Api.Files.UploadSessionAppendArg.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.Files.UploadSessionLookupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="uploadSessionAppendArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppendV2(UploadSessionAppendArg uploadSessionAppendArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendV2Async(uploadSessionAppendArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>When the parameter close is set, this call will close the session.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// anymore with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendV2Async(UploadSessionCursor cursor,
                                                 bool close = false,
                                                 io.Stream body = null)
        {
            var uploadSessionAppendArg = new UploadSessionAppendArg(cursor,
                                                                    close);

            return this.UploadSessionAppendV2Async(uploadSessionAppendArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// anymore with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppendV2(UploadSessionCursor cursor,
                                                           bool close = false,
                                                           io.Stream body = null,
                                                           sys.AsyncCallback callback = null,
                                                           object callbackState = null)
        {
            var uploadSessionAppendArg = new UploadSessionAppendArg(cursor,
                                                                    close);

            return this.BeginUploadSessionAppendV2(uploadSessionAppendArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public void EndUploadSessionAppendV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use UploadSessionAppendAsync instead.")]
        public t.Task UploadSessionAppendAsync(UploadSessionCursor uploadSessionCursor, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionCursor, enc.Empty, UploadSessionLookupError>(uploadSessionCursor, body, "content", "/files/upload_session/append", "user", global::Dropbox.Api.Files.UploadSessionCursor.Encoder, enc.EmptyDecoder.Instance, global::Dropbox.Api.Files.UploadSessionLookupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginUploadSessionAppend instead.")]
        public sys.IAsyncResult BeginUploadSessionAppend(UploadSessionCursor uploadSessionCursor, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendAsync(uploadSessionCursor, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync"
        /// />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use UploadSessionAppendAsync instead.")]
        public t.Task UploadSessionAppendAsync(string sessionId,
                                               ulong offset,
                                               io.Stream body)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.UploadSessionAppendAsync(uploadSessionCursor, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync"
        /// />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginUploadSessionAppend instead.")]
        public sys.IAsyncResult BeginUploadSessionAppend(string sessionId,
                                                         ulong offset,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.BeginUploadSessionAppend(uploadSessionCursor, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndUploadSessionAppend instead.")]
        public void EndUploadSessionAppend(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionFinishArg, FileMetadata, UploadSessionFinishError>(uploadSessionFinishArg, body, "content", "/files/upload_session/finish", "user", global::Dropbox.Api.Files.UploadSessionFinishArg.Encoder, global::Dropbox.Api.Files.FileMetadata.Decoder, global::Dropbox.Api.Files.UploadSessionFinishError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishAsync(uploadSessionFinishArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionCursor cursor,
                                                             CommitInfo commit,
                                                             io.Stream body)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.UploadSessionFinishAsync(uploadSessionFinishArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionCursor cursor,
                                                         CommitInfo commit,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.BeginUploadSessionFinish(uploadSessionFinishArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public FileMetadata EndUploadSessionFinish(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>This route helps you commit many files at once into a user's Dropbox. Use
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" /> and
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// to upload file contents. We recommend uploading many files in parallel to increase
        /// throughput. Once the file contents have been uploaded, rather than calling <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" />, use
        /// this route to finish all your upload sessions in a single request.</para>
        /// <para><see cref="Dropbox.Api.Files.UploadSessionStartArg.Close" /> or <see
        /// cref="Dropbox.Api.Files.UploadSessionAppendArg.Close" /> needs to be true for the
        /// last <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync"
        /// /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> call.
        /// The maximum size of a file one can upload to an upload session is 350 GB.</para>
        /// <para>This route will return a job_id immediately and do the async commit job in
        /// background. Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishBatchCheckAsync"
        /// /> to check the job status.</para>
        /// <para>For the same account, this route should be executed serially. That means you
        /// should not start the next job before current job finishes. We allow up to 1000
        /// entries in a single request.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="uploadSessionFinishBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionFinishBatchLaunch> UploadSessionFinishBatchAsync(UploadSessionFinishBatchArg uploadSessionFinishBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<UploadSessionFinishBatchArg, UploadSessionFinishBatchLaunch, enc.Empty>(uploadSessionFinishBatchArg, "api", "/files/upload_session/finish_batch", "user", global::Dropbox.Api.Files.UploadSessionFinishBatchArg.Encoder, global::Dropbox.Api.Files.UploadSessionFinishBatchLaunch.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatch(UploadSessionFinishBatchArg uploadSessionFinishBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishBatchAsync(uploadSessionFinishBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>This route helps you commit many files at once into a user's Dropbox. Use
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync" /> and
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// to upload file contents. We recommend uploading many files in parallel to increase
        /// throughput. Once the file contents have been uploaded, rather than calling <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" />, use
        /// this route to finish all your upload sessions in a single request.</para>
        /// <para><see cref="Dropbox.Api.Files.UploadSessionStartArg.Close" /> or <see
        /// cref="Dropbox.Api.Files.UploadSessionAppendArg.Close" /> needs to be true for the
        /// last <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionStartAsync"
        /// /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> call.
        /// The maximum size of a file one can upload to an upload session is 350 GB.</para>
        /// <para>This route will return a job_id immediately and do the async commit job in
        /// background. Use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishBatchCheckAsync"
        /// /> to check the job status.</para>
        /// <para>For the same account, this route should be executed serially. That means you
        /// should not start the next job before current job finishes. We allow up to 1000
        /// entries in a single request.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="entries">Commit information for each file in the batch.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionFinishBatchLaunch> UploadSessionFinishBatchAsync(col.IEnumerable<UploadSessionFinishArg> entries)
        {
            var uploadSessionFinishBatchArg = new UploadSessionFinishBatchArg(entries);

            return this.UploadSessionFinishBatchAsync(uploadSessionFinishBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch route.</para>
        /// </summary>
        /// <param name="entries">Commit information for each file in the batch.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatch(col.IEnumerable<UploadSessionFinishArg> entries,
                                                              sys.AsyncCallback callback,
                                                              object callbackState = null)
        {
            var uploadSessionFinishBatchArg = new UploadSessionFinishBatchArg(entries);

            return this.BeginUploadSessionFinishBatch(uploadSessionFinishBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish batch
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public UploadSessionFinishBatchLaunch EndUploadSessionFinishBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionFinishBatchLaunch>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishBatchAsync" />.
        /// If success, it returns list of result for each entry.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<UploadSessionFinishBatchJobStatus> UploadSessionFinishBatchCheckAsync(global::Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<global::Dropbox.Api.Async.PollArg, UploadSessionFinishBatchJobStatus, global::Dropbox.Api.Async.PollError>(pollArg, "api", "/files/upload_session/finish_batch/check", "user", global::Dropbox.Api.Async.PollArg.Encoder, global::Dropbox.Api.Files.UploadSessionFinishBatchJobStatus.Decoder, global::Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch check
        /// route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatchCheck(global::Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishBatchAsync" />.
        /// If success, it returns list of result for each entry.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<UploadSessionFinishBatchJobStatus> UploadSessionFinishBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.UploadSessionFinishBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch check
        /// route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatchCheck(string asyncJobId,
                                                                   sys.AsyncCallback callback,
                                                                   object callbackState = null)
        {
            var pollArg = new global::Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginUploadSessionFinishBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish batch
        /// check route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="global::Dropbox.Api.Async.PollError"/>.</exception>
        public UploadSessionFinishBatchJobStatus EndUploadSessionFinishBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionFinishBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Upload sessions allow you to upload a single file in one or more requests,
        /// for example where the size of the file is greater than 150 MB.  This call starts a
        /// new upload session with the given data. You can then use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> to
        /// add more data and <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" /> to save
        /// all the data to a file in Dropbox.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>An upload session can be used for a maximum of 48 hours. Attempting to use an
        /// <see cref="Dropbox.Api.Files.UploadSessionStartResult.SessionId" /> with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> or
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" />
        /// more than 48 hours after its creation will return a <see
        /// cref="Dropbox.Api.Files.UploadSessionLookupError.NotFound" />.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="uploadSessionStartArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(UploadSessionStartArg uploadSessionStartArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionStartArg, UploadSessionStartResult, enc.Empty>(uploadSessionStartArg, body, "content", "/files/upload_session/start", "user", global::Dropbox.Api.Files.UploadSessionStartArg.Encoder, global::Dropbox.Api.Files.UploadSessionStartResult.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="uploadSessionStartArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(UploadSessionStartArg uploadSessionStartArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionStartAsync(uploadSessionStartArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Upload sessions allow you to upload a single file in one or more requests,
        /// for example where the size of the file is greater than 150 MB.  This call starts a
        /// new upload session with the given data. You can then use <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> to
        /// add more data and <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" /> to save
        /// all the data to a file in Dropbox.</para>
        /// <para>A single request should not upload more than 150 MB. The maximum size of a
        /// file one can upload to an upload session is 350 GB.</para>
        /// <para>An upload session can be used for a maximum of 48 hours. Attempting to use an
        /// <see cref="Dropbox.Api.Files.UploadSessionStartResult.SessionId" /> with <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" /> or
        /// <see cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionFinishAsync" />
        /// more than 48 hours after its creation will return a <see
        /// cref="Dropbox.Api.Files.UploadSessionLookupError.NotFound" />.</para>
        /// <para>Calls to this endpoint will count as data transport calls for any Dropbox
        /// Business teams with a limit on the number of data transport calls allowed per
        /// month. For more information, see the <a
        /// href="https://www.dropbox.com/developers/reference/data-transport-limit">Data
        /// transport limit page</a>.</para>
        /// </summary>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// anymore with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(bool close = false,
                                                                        io.Stream body = null)
        {
            var uploadSessionStartArg = new UploadSessionStartArg(close);

            return this.UploadSessionStartAsync(uploadSessionStartArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesUserRoutes.UploadSessionAppendV2Async" />
        /// anymore with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(bool close = false,
                                                        io.Stream body = null,
                                                        sys.AsyncCallback callback = null,
                                                        object callbackState = null)
        {
            var uploadSessionStartArg = new UploadSessionStartArg(close);

            return this.BeginUploadSessionStart(uploadSessionStartArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session start route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public UploadSessionStartResult EndUploadSessionStart(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionStartResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }
    }
}
